<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>MindKeep</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="app">
        <div class="app-header">
            <h1><span class="brain-animation">🧠</span> MindKeep</h1>
            <div class="search-bar">
                <input type="text" id="searchInput" placeholder="Search notes..." class="search-input">
            </div>
            <button id="updateBtn" class="update-btn" onclick="checkForUpdates()">Check Updates</button>
        </div>
        
        <div class="app-body">
            <div class="sidebar">
                <div class="sidebar-header">
                    <div class="categories-tree" id="categoriesTree">
                        <div class="category-item root-category active" onclick="selectCategory('all')">
                            <span class="category-icon">📁</span>
                            <span class="category-name">All Notes</span>
                            <span class="note-count">0</span>
                        </div>
                    </div>
                    <div class="sidebar-controls">
                        <div class="category-actions">
                            <button class="category-btn" onclick="createNewCategory()" title="Create Category">
                                <span class="btn-icon">📁</span>
                            </button>
                            <button class="category-btn" onclick="manageCategories()" title="Manage Categories">
                                <span class="btn-icon">⚙️</span>
                            </button>
                        </div>
                        <select id="sortSelector" class="sort-selector" onchange="changeSorting()">
                            <option value="updated_at DESC">Recent</option>
                            <option value="created_at DESC">Created</option>
                            <option value="title ASC">A-Z</option>
                            <option value="title DESC">Z-A</option>
                        </select>
                    </div>
                    <div class="bulk-actions" id="bulkActions" style="display: none;" data-selected-count="0">
                        <div class="bulk-info">
                            <span class="selection-count">0 selected</span>
                            <button class="bulk-exit-btn" onclick="toggleBulkMode()" title="Exit selection mode">✕</button>
                        </div>
                        <div class="bulk-buttons">
                            <button class="bulk-btn delete-btn" onclick="bulkDelete()" title="Delete selected notes">
                                <span class="btn-icon">🗑️</span>
                                <span class="btn-text">Delete</span>
                            </button>
                            <button class="bulk-btn move-btn" onclick="bulkMove()" title="Move selected notes">
                                <span class="btn-icon">📁</span>
                                <span class="btn-text">Move</span>
                            </button>
                            <button class="bulk-btn duplicate-btn" onclick="findDuplicates()" title="Find duplicate notes">
                                <span class="btn-icon">🔍</span>
                                <span class="btn-text">Duplicates</span>
                            </button>
                        </div>
                    </div>
                    <div class="note-actions">
                        <button class="new-note-btn" onclick="createNewNote()" style="display: flex;">
                            <span class="btn-icon">📝</span>
                            <span class="btn-text">New</span>
                        </button>
                        <button class="template-btn" onclick="showTemplateModal()" style="display: flex;">
                            <span class="btn-icon">📋</span>
                            <span class="btn-text">Template</span>
                        </button>
                        <button class="bulk-toggle-btn" onclick="toggleBulkMode()">
                            <span class="btn-icon">☑️</span>
                            <span class="btn-text">Select</span>
                        </button>
                    </div>
                </div>
                <div id="notesList" class="notes-list">
                    <div class="no-notes-message">No notes found</div>
                </div>

            </div>
            
            <div class="main-content">
                <div id="welcomeScreen" class="welcome">
                    <div class="brain-animation-large">🧠</div>
                    <h2>Welcome to MindKeep</h2>
                    <p>Your offline knowledge vault</p>
                </div>
                
                <div id="viewer" class="viewer" style="display: none;">
                    <div class="viewer-header">
                        <h1 id="viewerTitle"></h1>
                        <div class="viewer-actions">
                            <button onclick="editNote()" class="edit-btn">
                                <span class="btn-icon">✏️</span>
                                <span class="btn-text">Edit</span>
                            </button>
                            <button onclick="moveNoteToCategory()" class="move-btn">
                                <span class="btn-icon">📁</span>
                                <span class="btn-text">Move</span>
                            </button>
                            <button onclick="deleteNote()" class="delete-btn">
                                <span class="btn-icon">🗑️</span>
                                <span class="btn-text">Delete</span>
                            </button>
                        </div>
                    </div>
                    <div id="viewerMeta" class="viewer-meta"></div>

                    <div id="viewerContent" class="viewer-content"></div>
                </div>
                
                <div id="editor" class="editor" style="display: none;">
                    <div class="editor-header">
                        <input type="text" id="noteTitle" class="title-input" placeholder="Note title...">
                        <div class="editor-actions">
                            <button onclick="saveCurrentNote()" class="save-btn">Save</button>
                            <button onclick="cancelEdit()" class="cancel-btn">Cancel</button>
                        </div>
                    </div>
                    <div class="editor-body">
                        <select id="noteCategory" class="tags-input">
                            <option value="">Select Category</option>
                        </select>
                        <input type="text" id="noteTags" class="tags-input" placeholder="Tags (e.g., #work #project #important)...">
                        <input type="text" id="noteDescription" class="tags-input" placeholder="Description...">
                        <div class="editor-toolbar">
                            <button onclick="formatText('bold')" class="toolbar-btn" title="Bold">𝐁</button>
                            <button onclick="formatText('italic')" class="toolbar-btn" title="Italic">𝐼</button>
                            <button onclick="formatText('underline')" class="toolbar-btn" title="Underline">𝐔</button>
                            <button onclick="formatText('strikeThrough')" class="toolbar-btn" title="Strikethrough">𝐒</button>
                            <button onclick="formatHeading('h1')" class="toolbar-btn" title="Heading 1">𝐇₁</button>
                            <button onclick="formatHeading('h2')" class="toolbar-btn" title="Heading 2">𝐇₂</button>
                            <button onclick="formatHeading('h3')" class="toolbar-btn" title="Heading 3">𝐇₃</button>
                            <button onclick="formatText('insertUnorderedList')" class="toolbar-btn" title="Bullet List">⦿</button>
                            <button onclick="formatText('insertOrderedList')" class="toolbar-btn" title="Numbered List">①</button>
                            <button onclick="formatCodeBlock()" class="toolbar-btn" title="Code Block">⧉</button>
                            <button onclick="insertLineBreak()" class="toolbar-btn" title="Section Divider">⸺</button>

                            <button onclick="alignText('left')" class="toolbar-btn" title="Align Left">⬅</button>
                            <button onclick="alignText('center')" class="toolbar-btn" title="Align Center">↔</button>
                            <button onclick="alignText('right')" class="toolbar-btn" title="Align Right">➡</button>
                            <button onclick="undoRedo('undo')" class="toolbar-btn" title="Undo">↶</button>
                            <button onclick="undoRedo('redo')" class="toolbar-btn" title="Redo">↷</button>
                            <div class="toolbar-help">
                                <div class="help-btn">❓</div>
                                <div class="help-tooltip">
                                    <div class="help-item"><strong>𝐁</strong> - Bold text</div>
                                    <div class="help-item"><strong>𝐼</strong> - Italic text</div>
                                    <div class="help-item"><strong>𝐔</strong> - Underline text</div>
                                    <div class="help-item"><strong>𝐒</strong> - Strikethrough text</div>
                                    <div class="help-item"><strong>𝐇₁/𝐇₂/𝐇₃</strong> - Headings</div>
                                    <div class="help-item"><strong>⦿</strong> - Bullet list</div>
                                    <div class="help-item"><strong>①</strong> - Numbered list</div>
                                    <div class="help-item"><strong>⧉</strong> - Code block</div>
                                    <div class="help-item"><strong>⸺</strong> - Section divider</div>
                                    <div class="help-item"><strong>⬅/↔/➡</strong> - Text alignment</div>
                                    <div class="help-item"><strong>↶/↷</strong> - Undo/Redo</div>
                                </div>
                            </div>
                        </div>

                        <div id="noteContent" class="content-editor" contenteditable="true" data-placeholder="Start writing your note..."></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Category Modal -->
    <div id="categoryModal" class="modal" style="display: none;">
        <div class="modal-content">
            <h3 id="categoryModalTitle">🎨 Create New Category</h3>
            <input type="text" id="categoryNameInput" placeholder="Category name" class="modal-input">
            <select id="parentCategoryInput" class="modal-input">
                <option value="">No parent (root category)</option>
            </select>
            <input type="color" id="categoryColorInput" value="#4a9eff" class="modal-input">
            <div class="modal-buttons">
                <button id="categorySaveBtn" onclick="saveCategoryModal()" class="modal-btn save">Create</button>
                <button onclick="closeCategoryModal()" class="modal-btn cancel">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- Delete Category Confirmation Modal -->
    <div id="deleteCategoryModal" class="modal" style="display: none;">
        <div class="modal-content delete-category-modal">
            <h3>🗑️ Delete Category</h3>
            <div id="deleteCategoryMessage" class="delete-category-content"></div>
            <div class="modal-buttons">
                <button id="confirmDeleteBtn" class="modal-btn delete-confirm">🗑️ Category</button>
                <button onclick="closeDeleteCategoryModal()" class="modal-btn cancel">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- Alert Modal -->
    <div id="alertModal" class="modal" style="display: none;">
        <div class="modal-content">
            <h3 id="alertTitle">ℹ️ Information</h3>
            <p id="alertMessage"></p>
            <div class="modal-buttons">
                <button onclick="closeAlert()" class="modal-btn save">OK</button>
            </div>
        </div>
    </div>
    
    <!-- Manage Categories Modal -->
    <div id="manageCategoriesModal" class="modal" style="display: none;">
        <div class="modal-content">
            <h3>⚙️ Manage Categories</h3>
            <div id="categoriesList" class="categories-list"></div>
            <div class="modal-buttons">
                <button onclick="closeManageCategoriesModal()" class="modal-btn cancel">Close</button>
            </div>
        </div>
    </div>
    
    <!-- Move Note Modal -->
    <div id="moveNoteModal" class="modal" style="display: none;">
        <div class="modal-content">
            <h3>📁 Move Note</h3>
            <select id="moveToCategory" class="modal-input">
                <option value="">Select Category</option>
            </select>
            <div class="modal-buttons">
                <button onclick="confirmMoveNote()" class="modal-btn save">Move</button>
                <button onclick="closeMoveNoteModal()" class="modal-btn cancel">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- Bulk Move Modal -->
    <div id="bulkMoveModal" class="modal" style="display: none;">
        <div class="modal-content">
            <h3>📁 Move Selected Notes</h3>
            <p>Move <span id="selectedCount">0</span> selected notes to:</p>
            <select id="bulkMoveToCategory" class="modal-input">
                <option value="">Select Category</option>
            </select>
            <div class="modal-buttons">
                <button onclick="confirmBulkMove()" class="modal-btn save">Move</button>
                <button onclick="closeBulkMoveModal()" class="modal-btn cancel">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- Duplicates Modal -->
    <div id="duplicatesModal" class="modal" style="display: none;">
        <div class="modal-content">
            <h3>🔍 Duplicate Notes</h3>
            <div id="duplicatesList" class="duplicates-list"></div>
            <div class="modal-buttons">
                <button onclick="closeDuplicatesModal()" class="modal-btn cancel">Close</button>
            </div>
        </div>
    </div>
    
    <!-- Confirmation Modal -->
    <div id="confirmModal" class="modal" style="display: none;">
        <div class="modal-content confirm-modal">
            <h3 id="confirmTitle">⚠️ Confirm Action</h3>
            <div id="confirmMessage" class="confirm-content"></div>
            <div class="modal-buttons">
                <button id="confirmYesBtn" class="modal-btn delete-confirm">Confirm</button>
                <button onclick="closeConfirmModal()" class="modal-btn cancel">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- Update Available Modal -->
    <div id="updateAvailableModal" class="modal" style="display: none;">
        <div class="modal-content">
            <h3>🎉 Update Available!</h3>
            <div class="update-info">
                <div class="version-comparison">
                    <div class="version-item">
                        <span class="version-label">Current Version:</span>
                        <span id="currentVersionText" class="version-number"></span>
                    </div>
                    <div class="version-arrow">→</div>
                    <div class="version-item">
                        <span class="version-label">Latest Version:</span>
                        <span id="latestVersionText" class="version-number"></span>
                    </div>
                </div>
                <div id="updateProgress" class="update-progress" style="display: none;">
                    <div class="progress-bar">
                        <div id="progressFill" class="progress-fill"></div>
                    </div>
                    <div id="progressText" class="progress-text">Downloading...</div>
                </div>
            </div>
            <div class="modal-buttons">
                <button id="installUpdateBtn" onclick="installUpdate()" class="modal-btn save">Install Update</button>
                <button onclick="closeUpdateAvailableModal()" class="modal-btn cancel">Later</button>
            </div>
        </div>
    </div>
    
    <!-- Floating In-Note Search -->
    <div id="floatingSearch" class="floating-search" style="display: none;">
        <input type="text" id="floatingSearchInput" placeholder="Search in note..." class="floating-search-input">
        <div class="floating-search-controls">
            <button onclick="navigateSearch('prev')" class="floating-nav-btn">↑</button>
            <button onclick="navigateSearch('next')" class="floating-nav-btn">↓</button>
            <span id="floatingSearchResults" class="floating-search-results"></span>
            <button onclick="closeFloatingSearch()" class="floating-close-btn">✕</button>
        </div>
    </div>
    
    <!-- Template Modal -->
    <div id="templateModal" class="modal" style="display: none;">
        <div class="modal-content template-modal">
            <h3>📋 Templates</h3>
            <div class="template-list" id="templateList">
                <div class="template-item" onclick="createFromTemplate('meeting')">
                    <span class="template-icon">💼</span>
                    <span class="template-name">Meeting Notes</span>
                </div>
                <div class="template-item" onclick="createFromTemplate('daily')">
                    <span class="template-icon">📅</span>
                    <span class="template-name">Daily Journal</span>
                </div>
                <div class="template-item" onclick="createFromTemplate('project')">
                    <span class="template-icon">📁</span>
                    <span class="template-name">Project Plan</span>
                </div>
                <div class="template-item" onclick="createFromTemplate('todo')">
                    <span class="template-icon">✅</span>
                    <span class="template-name">To-Do List</span>
                </div>
                <div class="template-item" onclick="createFromTemplate('research')">
                    <span class="template-icon">🔍</span>
                    <span class="template-name">Research Notes</span>
                </div>
                <div class="template-item" onclick="createFromTemplate('blank')">
                    <span class="template-icon">📄</span>
                    <span class="template-name">Blank Note</span>
                </div>
            </div>
            <div class="modal-buttons">
                <button onclick="showAddTemplateForm()" class="modal-btn save">📋 Add Template</button>
                <button onclick="resetTemplates()" class="modal-btn" style="background: #f39c12;">🔄 Reset Templates</button>
                <button onclick="closeTemplateModal()" class="modal-btn cancel">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- Add Template Modal -->
    <div id="addTemplateModal" class="modal" style="display: none;">
        <div class="modal-content">
            <h3>➕ Create Template</h3>
            <input type="text" id="templateNameInput" placeholder="Template name" class="modal-input">
            <input type="text" id="templateIconInput" placeholder="Icon (emoji)" class="modal-input" maxlength="2">
            <input type="text" id="templateTitleInput" placeholder="Note title template" class="modal-input">
            <textarea id="templateContentInput" placeholder="Template content..." class="modal-textarea"></textarea>
            <div class="modal-buttons">
                <button onclick="saveTemplate()" class="modal-btn save">Save Template</button>
                <button onclick="closeAddTemplateModal()" class="modal-btn cancel">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- Template Editor Modal -->
    <div id="templateEditorModal" class="modal" style="display: none;">
        <div class="modal-content template-editor-modal">
            <div class="editor-header">
                <input type="text" id="templateEditorName" class="title-input" placeholder="Template name...">
                <div class="editor-actions">
                    <button onclick="saveTemplateEditor()" class="save-btn">Save Template</button>
                    <button onclick="closeTemplateEditor()" class="cancel-btn">Cancel</button>
                </div>
            </div>
            <div class="editor-body">
                <div class="template-meta">
                    <input type="text" id="templateEditorIcon" class="tags-input" placeholder="Icon (emoji)" maxlength="2" style="width: 100px;">
                    <input type="text" id="templateEditorTitle" class="tags-input" placeholder="Note title template (use {date} for current date)..." style="flex: 1; margin-left: 0.5rem;">
                </div>
                <div class="editor-toolbar">
                    <button onclick="formatTemplateText('bold')" class="toolbar-btn"><b>B</b></button>
                    <button onclick="formatTemplateText('italic')" class="toolbar-btn"><i>I</i></button>
                    <button onclick="formatTemplateText('underline')" class="toolbar-btn"><u>U</u></button>
                    <button onclick="formatTemplateHeading('h1')" class="toolbar-btn">H1</button>
                    <button onclick="formatTemplateHeading('h2')" class="toolbar-btn">H2</button>
                    <button onclick="formatTemplateHeading('h3')" class="toolbar-btn">H3</button>
                    <button onclick="formatTemplateText('insertUnorderedList')" class="toolbar-btn">•</button>
                    <button onclick="formatTemplateText('insertOrderedList')" class="toolbar-btn">1.</button>
                    <button onclick="insertTemplatePlaceholder()" class="toolbar-btn" title="Insert {date} placeholder">📅</button>
                </div>
                <div id="templateEditorContent" class="content-editor" contenteditable="true" data-placeholder="Start writing your template content..."></div>
            </div>
        </div>
    </div>
    
    <!-- Category Context Menu -->
    <div id="categoryContextMenu" class="context-menu" style="display: none;">
        <div class="context-item" onclick="contextEditCategory()">
            <span class="context-icon">✏️</span>
            <span class="context-text">Edit</span>
        </div>
        <div class="context-item" onclick="contextCreateSubcategory()">
            <span class="context-icon">📁</span>
            <span class="context-text">Add Subcategory</span>
        </div>
        <div class="context-separator"></div>
        <div class="context-item context-delete" onclick="contextDeleteCategory()">
            <span class="context-icon">🗑️</span>
            <span class="context-text">Delete</span>
        </div>
    </div>
    
    <!-- Note Context Menu -->
    <div id="noteContextMenu" class="context-menu" style="display: none;">
        <div class="context-item" onclick="contextEditNote()">
            <span class="context-icon">✏️</span>
            <span class="context-text">Edit</span>
        </div>
        <div class="context-item" onclick="contextMoveNote()">
            <span class="context-icon">📁</span>
            <span class="context-text">Move</span>
        </div>
        <div class="context-item" onclick="contextPinNote()">
            <span class="context-icon">📌</span>
            <span class="context-text">Pin/Unpin</span>
        </div>
        <div class="context-separator"></div>
        <div class="context-item context-delete" onclick="contextDeleteNote()">
            <span class="context-icon">🗑️</span>
            <span class="context-text">Delete</span>
        </div>
    </div>

        // <script>
        const { ipcRenderer } = require('electron');
        
        // App data
        let categories = [];
        let notes = [];
        let editingCategory = null;
        
        // Initialize app
        async function initApp() {
            try {
                // Load categories from database
                categories = await ipcRenderer.invoke('db-get-categories');
                
                // Load notes from database
                notes = await ipcRenderer.invoke('db-get-notes');
                
                updateCategorySelector();
                updateNotesList();
            } catch (error) {
                console.error('Initialization error:', error);
                updateCategorySelector();
                updateNotesList();
            }
        }
        
        async function loadNotes() {
            try {
                notes = await ipcRenderer.invoke('db-get-notes');
            } catch (error) {
                console.error('Error loading notes:', error);
            }
        }
        
        let currentCategory = 'all';
        let bulkMode = false;
        let selectedNotes = new Set();
        
        let expandedCategories = new Set();
        
        function updateCategorySelector() {
            const tree = document.getElementById('categoriesTree');
            const noteCategory = document.getElementById('noteCategory');
            
            const buildCategoryOptions = (cats, parentName = null, level = 0) => {
                const children = cats.filter(cat => cat.parent === parentName);
                let options = '';
                
                children.forEach(cat => {
                    const indent = '\u00A0\u00A0\u00A0\u00A0'.repeat(level);
                    options += `<option value="${cat.name}">${indent}${cat.name}</option>`;
                    options += buildCategoryOptions(cats, cat.name, level + 1);
                });
                
                return options;
            };
            
            // Build tree structure
            const allNotesCount = notes.length;
            const rootCats = categories.filter(cat => !cat.parent);
            
            let treeHtml = `
                <div class="category-item root-category ${currentCategory === 'all' ? 'active' : ''}" onclick="selectCategory('all')">
                    <span class="category-icon">📁</span>
                    <span class="category-name">All Notes</span>
                    <span class="note-count">${allNotesCount}</span>
                </div>
            `;
            
            categories.filter(cat => !cat.parent).forEach(cat => {
                const noteCount = notes.filter(note => note.category === cat.name).length;
                const children = categories.filter(c => c.parent === cat.name);
                const hasChildren = children.length > 0;
                const isExpanded = expandedCategories.has(cat.name);
                
                treeHtml += `
                    <div class="category-item ${currentCategory === cat.name ? 'active' : ''}" 
                         data-category-name="${cat.name}"
                         ondragover="handleCategoryReorderDragOver(event)" 
                         ondragleave="handleCategoryDragLeave(event)" 
                         ondrop="handleCategoryReorderDrop(event)">
                        <span class="drag-handle" 
                              draggable="true"
                              ondragstart="handleCategoryDragStart(event)"
                              ondragend="handleCategoryDragEnd(event)"
                              title="Drag to reorder">⋮</span>
                        ${hasChildren ? `<span class="expand-arrow ${isExpanded ? 'expanded' : ''}" onclick="toggleCategory('${cat.name}'); event.stopPropagation();">▶</span>` : '<span class="expand-spacer"></span>'}
                        <span class="category-icon" style="color: ${cat.color}" onclick="selectCategory('${cat.name}')">📁</span>
                        <span class="category-name" onclick="selectCategory('${cat.name}')" oncontextmenu="window.showCategoryContextMenu(event, '${cat.name}'); return false;">${cat.name}</span>
                        <span class="note-count" onclick="selectCategory('${cat.name}')">${noteCount}</span>
                    </div>
                `;
                
                if (hasChildren && isExpanded) {
                    const buildSubTree = (parentName, level) => {
                        const subChildren = categories.filter(c => c.parent === parentName);
                        let subHtml = '';
                        subChildren.forEach(subCat => {
                            const subNoteCount = notes.filter(note => note.category === subCat.name).length;
                            const subSubChildren = categories.filter(c => c.parent === subCat.name);
                            const subHasChildren = subSubChildren.length > 0;
                            const subIsExpanded = expandedCategories.has(subCat.name);
                            const marginLeft = level * 1.5;
                            
                            subHtml += `
                                <div class="category-item ${currentCategory === subCat.name ? 'active' : ''}" 
                                     style="margin-left: ${marginLeft}rem;"
                                     data-category-name="${subCat.name}"
                                     ondragover="handleCategoryReorderDragOver(event)" 
                                     ondragleave="handleCategoryDragLeave(event)" 
                                     ondrop="handleCategoryReorderDrop(event)">
                                    <span class="drag-handle" 
                                          draggable="true"
                                          ondragstart="handleCategoryDragStart(event)"
                                          ondragend="handleCategoryDragEnd(event)"
                                          title="Drag to reorder">⋮</span>
                                    ${subHasChildren ? `<span class="expand-arrow ${subIsExpanded ? 'expanded' : ''}" onclick="toggleCategory('${subCat.name}'); event.stopPropagation();">▶</span>` : '<span class="expand-spacer"></span>'}
                                    <span class="category-icon" style="color: ${subCat.color}" onclick="selectCategory('${subCat.name}')">📁</span>
                                    <span class="category-name" onclick="selectCategory('${subCat.name}')" oncontextmenu="window.showCategoryContextMenu(event, '${subCat.name}'); return false;">${subCat.name}</span>
                                    <span class="note-count" onclick="selectCategory('${subCat.name}')">${subNoteCount}</span>
                                </div>
                            `;
                            
                            if (subHasChildren && subIsExpanded) {
                                subHtml += buildSubTree(subCat.name, level + 1);
                            }
                        });
                        return subHtml;
                    };
                    
                    treeHtml += buildSubTree(cat.name, 1);
                }
            });
            
            tree.innerHTML = treeHtml;
            
            const noteOptions = '<option value="">Select Category</option>' + buildCategoryOptions(categories);
            noteCategory.innerHTML = noteOptions;
        }
        
        function toggleCategory(categoryName) {
            if (expandedCategories.has(categoryName)) {
                expandedCategories.delete(categoryName);
            } else {
                expandedCategories.add(categoryName);
            }
            updateCategorySelector();
        }
        
        function selectCategory(categoryName) {
            currentCategory = categoryName;
            updateCategorySelector();
            updateNotesList();
        }
        

        
        function updateNotesList() {
            const notesList = document.getElementById('notesList');
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            
            // Filter notes by selected category
            let filteredNotes = currentCategory === 'all' ? 
                notes : notes.filter(note => note.category === currentCategory);
            
            // Filter by search term
            if (searchTerm) {
                if (searchTerm.startsWith('#')) {
                    // Tag search
                    const tagSearch = searchTerm.substring(1);
                    filteredNotes = filteredNotes.filter(note => 
                        note.tags && note.tags.some(tag => tag.toLowerCase().includes(tagSearch))
                    );
                } else {
                    // Regular search
                    filteredNotes = filteredNotes.filter(note => 
                        note.title.toLowerCase().includes(searchTerm) ||
                        note.content.toLowerCase().includes(searchTerm) ||
                        note.description.toLowerCase().includes(searchTerm)
                    );
                }
            }
            
            if (filteredNotes.length === 0) {
                notesList.innerHTML = '<div class="no-notes-message">No notes found</div>';
                return;
            }
            
            notesList.innerHTML = filteredNotes.map(note => {
                const category = categories.find(cat => cat.name === note.category) || { color: '#4a9eff' };
                const isSelected = selectedNotes.has(note.id);
                const checkboxHtml = bulkMode ? `<input type="checkbox" ${isSelected ? 'checked' : ''} onchange="toggleNoteSelection('${note.id}')" onclick="event.stopPropagation()">` : '';
                const pinIcon = note.isPinned ? '📌' : '';
                
                return `
                    <div class="note-item ${isSelected ? 'selected' : ''} ${note.isPinned ? 'pinned' : ''}" 
                         style="border-left: 4px solid ${category.color}; padding: 1rem; margin-bottom: 0.5rem; background: ${isSelected ? '#555' : '#404040'}; border-radius: 4px; cursor: pointer; display: flex; align-items: center; gap: 10px;" 
                         draggable="true" 
                         data-note-id="${note.id}"
                         ondragstart="handleNoteDragStart(event)"
                         ondragend="handleNoteDragEnd(event)"
                         onclick="${bulkMode ? `toggleNoteSelection('${note.id}')` : `viewNote('${note.id}')`}"
                         oncontextmenu="showNoteContextMenu(event, '${note.id}'); return false;">
                        ${checkboxHtml}
                        <div style="flex: 1;">
                            <div style="font-weight: bold; color: #e0e0e0; display: flex; align-items: center; gap: 0.5rem;">
                                ${pinIcon}
                                <span>${highlightSearchTerm(note.title)}</span>
                            </div>
                            <div style="color: #888; font-size: 0.9rem; margin-top: 0.5rem;">${new Date(note.updatedAt).toLocaleDateString()}</div>
                        </div>
                        ${!bulkMode ? `<button class="pin-btn" onclick="togglePin('${note.id}'); event.stopPropagation();" title="${note.isPinned ? 'Unpin' : 'Pin'} note">${note.isPinned ? '📌' : '📍'}</button>` : ''}
                    </div>
                `;
            }).join('');
        }
        
        // Process note links @NoteName
        function processNoteLinks(text) {
            if (!text) return text;
            
            return text.replace(/@([A-Za-z0-9\s\-_]+)/g, (match, noteName) => {
                const trimmedName = noteName.trim();
                const linkedNote = notes.find(note => 
                    note.title.toLowerCase().trim() === trimmedName.toLowerCase().trim()
                );
                
                if (linkedNote) {
                    return `<span class="note-link" data-note-id="${linkedNote.id}" style="color: #4a9eff !important; cursor: pointer; text-decoration: underline; font-weight: bold; background: rgba(74, 158, 255, 0.1); padding: 0.1rem 0.2rem; border-radius: 3px;">@${trimmedName}</span>`;
                } else {
                    return `<span style="color: #888;">@${trimmedName}</span>`;
                }
            });
        }
        
        // Bulk operations
        function toggleBulkMode() {
            bulkMode = !bulkMode;
            selectedNotes.clear();
            const bulkActions = document.getElementById('bulkActions');
            const toggleBtn = document.querySelector('.bulk-toggle-btn');
            const toggleIcon = toggleBtn.querySelector('.btn-icon');
            const toggleText = toggleBtn.querySelector('.btn-text');
            const newNoteBtn = document.querySelector('.new-note-btn');
            const templateBtn = document.querySelector('.template-btn');
            
            bulkActions.style.display = bulkMode ? 'flex' : 'none';
            
            if (bulkMode) {
                toggleBtn.style.display = 'none';
                newNoteBtn.style.display = 'none';
                templateBtn.style.display = 'none';
            } else {
                toggleBtn.style.display = 'flex';
                newNoteBtn.style.display = 'flex';
                templateBtn.style.display = 'flex';
                toggleIcon.textContent = '☑️';
                toggleText.textContent = 'Select Multiple';
                toggleBtn.style.background = 'linear-gradient(135deg, #6c757d, #5a6268)';
                toggleBtn.classList.remove('exit-mode');
            }
            
            updateNotesList();
        }
        
        function toggleNoteSelection(noteId) {
            if (selectedNotes.has(noteId)) {
                selectedNotes.delete(noteId);
            } else {
                selectedNotes.add(noteId);
            }
            
            // Update selection counter immediately
            updateSelectionCounter();
            updateNotesList();
        }
        
        function updateSelectionCounter() {
            const bulkActions = document.getElementById('bulkActions');
            const selectionCount = document.querySelector('.selection-count');
            
            if (bulkActions && selectionCount && bulkMode) {
                const count = selectedNotes.size;
                bulkActions.setAttribute('data-selected-count', count);
                selectionCount.textContent = `${count} selected`;
                
                // Enable/disable action buttons based on selection
                const actionButtons = document.querySelectorAll('.bulk-btn:not(.bulk-exit-btn)');
                actionButtons.forEach(btn => {
                    btn.disabled = count === 0;
                    btn.style.opacity = count === 0 ? '0.5' : '1';
                });
            }
        }
        
        function bulkDelete() {
            if (selectedNotes.size === 0) {
                showAlert('⚠️ Warning', 'No notes selected.');
                return;
            }
            
            showConfirm(
                'Delete Selected Notes',
                `<div class="delete-warning">
                    <div class="warning-icon">🗑️</div>
                    <div class="warning-text">
                        <strong>Delete ${selectedNotes.size} selected note${selectedNotes.size > 1 ? 's' : ''}?</strong>
                        <p>This action cannot be undone.</p>
                    </div>
                </div>`,
                () => {
                selectedNotes.forEach(noteId => {
                    try {
                        const filePath = path.join(notesDir, noteId + '.json');
                        if (fs.existsSync(filePath)) {
                            fs.unlinkSync(filePath);
                        }
                        notes = notes.filter(note => note.id !== noteId);
                    } catch (error) {
                        console.error('Error deleting note:', error);
                    }
                });
                
                    selectedNotes.clear();
                    updateNotesList();
                    showAlert('✅ Success', 'Selected notes deleted!');
                },
                'Delete Notes',
                '🗑️'
            );
        }
        
        function bulkMove() {
            if (selectedNotes.size === 0) {
                showAlert('⚠️ Warning', 'No notes selected.');
                return;
            }
            
            document.getElementById('selectedCount').textContent = selectedNotes.size;
            const buildHierarchicalOptions = (parentName = null, level = 0) => {
                const children = categories.filter(cat => cat.parent === parentName);
                let options = '';
                
                children.forEach(cat => {
                    const indent = '\u00A0\u00A0\u00A0'.repeat(level);
                    options += `<option value="${cat.name}">${indent}${cat.name}</option>`;
                    options += buildHierarchicalOptions(cat.name, level + 1);
                });
                
                return options;
            };
            
            const bulkMoveSelect = document.getElementById('bulkMoveToCategory');
            bulkMoveSelect.innerHTML = '<option value="">Select Category</option>' + buildHierarchicalOptions();
            document.getElementById('bulkMoveModal').style.display = 'flex';
        }
        
        function confirmBulkMove() {
            const newCategory = document.getElementById('bulkMoveToCategory').value;
            if (!newCategory) {
                showAlert('⚠️ Warning', 'Please select a category.');
                return;
            }
            
            selectedNotes.forEach(noteId => {
                const note = notes.find(n => n.id === noteId);
                if (note) {
                    note.category = newCategory;
                    note.updatedAt = new Date().toISOString();
                    try {
                        const filePath = path.join(notesDir, note.id + '.json');
                        fs.writeFileSync(filePath, JSON.stringify(note, null, 2));
                    } catch (error) {
                        console.error('Error updating note:', error);
                    }
                }
            });
            
            selectedNotes.clear();
            updateNotesList();
            closeBulkMoveModal();
            showAlert('✅ Success', 'Notes moved successfully!');
        }
        
        function closeBulkMoveModal() {
            document.getElementById('bulkMoveModal').style.display = 'none';
        }
        
        // Find duplicates
        function findDuplicates() {
            const duplicates = [];
            const seen = new Map();
            
            notes.forEach(note => {
                const key = note.title.toLowerCase().trim();
                if (seen.has(key)) {
                    const existing = seen.get(key);
                    if (!duplicates.find(d => d.original.id === existing.id)) {
                        duplicates.push({ original: existing, duplicates: [note] });
                    } else {
                        duplicates.find(d => d.original.id === existing.id).duplicates.push(note);
                    }
                } else {
                    seen.set(key, note);
                }
            });
            
            if (duplicates.length === 0) {
                showAlert('✅ No Duplicates', 'No duplicate notes found!');
                return;
            }
            
            const duplicatesList = document.getElementById('duplicatesList');
            duplicatesList.innerHTML = duplicates.map(group => `
                <div class="duplicate-group" style="margin-bottom: 20px; padding: 15px; background: #333; border-radius: 8px;">
                    <h4 style="color: #e0e0e0; margin-bottom: 10px;">"${group.original.title}"</h4>
                    <div class="duplicate-item" style="margin-bottom: 10px; padding: 10px; background: #404040; border-radius: 4px;">
                        <strong>Original:</strong> ${new Date(group.original.createdAt).toLocaleDateString()}
                        <button onclick="viewNote('${group.original.id}'); closeDuplicatesModal();" style="margin-left: 10px;">View</button>
                    </div>
                    ${group.duplicates.map(dup => `
                        <div class="duplicate-item" style="margin-bottom: 5px; padding: 10px; background: #555; border-radius: 4px;">
                            <strong>Duplicate:</strong> ${new Date(dup.createdAt).toLocaleDateString()}
                            <button onclick="viewNote('${dup.id}'); closeDuplicatesModal();" style="margin-left: 10px;">View</button>
                            <button onclick="deleteDuplicate('${dup.id}')" style="margin-left: 5px; background: #d32f2f;">Delete</button>
                        </div>
                    `).join('')}
                </div>
            `).join('');
            
            document.getElementById('duplicatesModal').style.display = 'flex';
        }
        
        async function deleteDuplicate(noteId) {
            const note = notes.find(n => n.id === noteId);
            showConfirm(
                'Delete Duplicate Note',
                `<div class="delete-warning">
                    <div class="warning-icon">🗑️</div>
                    <div class="warning-text">
                        <strong>Delete "${note ? note.title : 'Unknown'}"?</strong>
                        <p>This duplicate note will be permanently deleted.</p>
                        <p style="color: #888; font-size: 0.9rem; margin-top: 0.5rem;">The original note will remain untouched.</p>
                    </div>
                </div>`,
                async () => {
                    try {
                        await ipcRenderer.invoke('db-delete-note', noteId);
                        notes = await ipcRenderer.invoke('db-get-notes');
                        updateNotesList();
                        findDuplicates(); // Refresh duplicates list
                        showAlert('✅ Success', 'Duplicate note deleted!');
                    } catch (error) {
                        showAlert('❌ Error', 'Error deleting note: ' + error.message);
                    }
                },
                'Delete Duplicate',
                '🗑️'
            );
        }
        
        function closeDuplicatesModal() {
            document.getElementById('duplicatesModal').style.display = 'none';
        }
        
        // Move single note
        function moveNoteToCategory() {
            if (!currentNote) return;
            
            const buildHierarchicalOptions = (parentName = null, level = 0) => {
                const children = categories.filter(cat => cat.parent === parentName && cat.name !== currentNote.category);
                let options = '';
                
                children.forEach(cat => {
                    const indent = '\u00A0\u00A0\u00A0'.repeat(level);
                    options += `<option value="${cat.name}">${indent}${cat.name}</option>`;
                    options += buildHierarchicalOptions(cat.name, level + 1);
                });
                
                return options;
            };
            
            const moveSelect = document.getElementById('moveToCategory');
            moveSelect.innerHTML = '<option value="">Select Category</option>' + buildHierarchicalOptions();
            document.getElementById('moveNoteModal').style.display = 'flex';
        }
        
        function confirmMoveNote() {
            const newCategory = document.getElementById('moveToCategory').value;
            if (!newCategory) {
                showAlert('⚠️ Warning', 'Please select a category.');
                return;
            }
            
            currentNote.category = newCategory;
            currentNote.updatedAt = new Date().toISOString();
            
            try {
                const filePath = path.join(notesDir, currentNote.id + '.json');
                fs.writeFileSync(filePath, JSON.stringify(currentNote, null, 2));
                
                // Update in array
                const index = notes.findIndex(n => n.id === currentNote.id);
                if (index >= 0) {
                    notes[index] = currentNote;
                }
                
                updateNotesList();
                viewNote(currentNote.id); // Refresh viewer
                closeMoveNoteModal();
                showAlert('✅ Success', 'Note moved successfully!');
            } catch (error) {
                showAlert('❌ Error', 'Error moving note: ' + error.message);
            }
        }
        
        function closeMoveNoteModal() {
            document.getElementById('moveNoteModal').style.display = 'none';
        }
        
        let currentNote = null;
        
        function viewNote(noteId) {
            currentNote = notes.find(note => note.id === noteId);
            if (currentNote) {
                document.getElementById('welcomeScreen').style.display = 'none';
                document.getElementById('editor').style.display = 'none';
                document.getElementById('viewer').style.display = 'flex';
                
                document.getElementById('viewerTitle').textContent = currentNote.title;
                document.getElementById('viewerMeta').innerHTML = `
                    <span>Category: ${currentNote.category}</span> • 
                    <span>Created: ${new Date(currentNote.createdAt).toLocaleString()}</span> • 
                    <span>Updated: ${new Date(currentNote.updatedAt).toLocaleString()}</span>
                    ${currentNote.tags && currentNote.tags.length > 0 ? `<br><span style="color: #ffc107;">🏷️ ${currentNote.tags.map(tag => '#' + tag).join(' ')}</span>` : ''}
                    ${currentNote.description ? `<br><span style="color: #4a9eff; font-style: italic;">📝 ${currentNote.description}</span>` : ''}
                `;
                
                // Process note links and set content
                const processedContent = processNoteLinks(currentNote.content || '');
                document.getElementById('viewerContent').innerHTML = processedContent || '<em>No content</em>';
                
                // Store original content for search functionality
                originalContent = document.getElementById('viewerContent').innerHTML;
            }
        }
        
        function editNote() {
            if (currentNote) {
                document.getElementById('viewer').style.display = 'none';
                document.getElementById('editor').style.display = 'flex';
                
                document.getElementById('noteTitle').value = currentNote.title;
                document.getElementById('noteContent').innerHTML = currentNote.content || '';
                document.getElementById('noteCategory').value = currentNote.category;
                document.getElementById('noteTags').value = currentNote.tags && currentNote.tags.length > 0 ? currentNote.tags.map(tag => '#' + tag).join(' ') : '';
                document.getElementById('noteDescription').value = currentNote.description;
                
                // Focus the content editor
                setTimeout(() => {
                    document.getElementById('noteContent').focus();
                }, 100);
            }
        }
        
        async function deleteNote() {
            if (!currentNote) return;
            
            showConfirm(
                'Delete Note',
                `<div class="delete-warning">
                    <div class="warning-icon">🗑️</div>
                    <div class="warning-text">
                        <strong>Delete "${currentNote.title}"?</strong>
                        <p>This note will be permanently deleted and cannot be recovered.</p>
                        <div style="margin-top: 1rem; padding: 0.5rem; background: #333; border-radius: 4px;">
                            <div style="font-size: 0.85rem; color: #bbb;">Category: ${currentNote.category}</div>
                            <div style="font-size: 0.85rem; color: #bbb;">Created: ${new Date(currentNote.createdAt).toLocaleDateString()}</div>
                        </div>
                    </div>
                </div>`,
                async () => {
                    try {
                        await ipcRenderer.invoke('db-delete-note', currentNote.id);
                        notes = await ipcRenderer.invoke('db-get-notes');
                        
                        // Update UI
                        updateNotesList();
                        
                        // Go back to welcome screen
                        document.getElementById('viewer').style.display = 'none';
                        document.getElementById('welcomeScreen').style.display = 'flex';
                        
                        currentNote = null;
                        showAlert('🗑️ Deleted', 'Note deleted successfully!');
                    } catch (error) {
                        showAlert('❌ Error', 'Error deleting note: ' + error.message);
                    }
                },
                'Delete Note',
                '🗑️'
            );
        }
        
        // Modal functions
        function showAlert(title, message, callback) {
            document.getElementById('alertTitle').textContent = title;
            document.getElementById('alertMessage').textContent = message;
            document.getElementById('alertModal').style.display = 'flex';
            
            // Store callback for when OK is clicked
            window.alertCallback = callback;
        }
        
        function closeAlert() {
            document.getElementById('alertModal').style.display = 'none';
            
            // Execute callback if provided
            if (window.alertCallback) {
                window.alertCallback();
                window.alertCallback = null;
            }
        }
        
        // Enhanced confirmation modal
        function showConfirm(title, message, onConfirm, confirmText = 'Confirm', icon = '⚠️') {
            document.getElementById('confirmTitle').innerHTML = `${icon} ${title}`;
            document.getElementById('confirmMessage').innerHTML = message;
            document.getElementById('confirmYesBtn').textContent = confirmText;
            document.getElementById('confirmYesBtn').onclick = () => {
                closeConfirmModal();
                onConfirm();
            };
            document.getElementById('confirmModal').style.display = 'flex';
        }
        
        function closeConfirmModal() {
            document.getElementById('confirmModal').style.display = 'none';
        }
        
        function createNewCategory() {
            editingCategory = null;
            document.getElementById('categoryNameInput').value = '';
            document.getElementById('categoryColorInput').value = '#4a9eff';
            
            const buildHierarchicalOptions = (parentName = null, level = 0) => {
                const children = categories.filter(cat => cat.parent === parentName);
                let options = '';
                
                children.forEach(cat => {
                    const indent = '\u00A0\u00A0\u00A0'.repeat(level);
                    options += `<option value="${cat.name}">${indent}${cat.name}</option>`;
                    options += buildHierarchicalOptions(cat.name, level + 1);
                });
                
                return options;
            };
            
            let parentOptions = '<option value="">No parent (root category)</option>';
            parentOptions += buildHierarchicalOptions();
            document.getElementById('parentCategoryInput').innerHTML = parentOptions;
            
            document.getElementById('categoryModal').style.display = 'flex';
            document.getElementById('categoryNameInput').focus();
        }
        
        function closeCategoryModal() {
            document.getElementById('categoryModal').style.display = 'none';
            document.getElementById('categoryNameInput').value = '';
            document.getElementById('categoryColorInput').value = '#4a9eff';
        }
        
        async function saveCategoryModal() {
            const categoryName = document.getElementById('categoryNameInput').value.trim();
            const parentCategory = document.getElementById('parentCategoryInput').value || null;
            const color = document.getElementById('categoryColorInput').value;
            
            if (categoryName) {
                if (!categories.find(cat => cat.name.toLowerCase() === categoryName.toLowerCase())) {
                    try {
                        await ipcRenderer.invoke('db-add-category', categoryName, color, parentCategory);
                        categories = await ipcRenderer.invoke('db-get-categories');
                        updateCategorySelector();
                        closeCategoryModal();
                        showAlert('✅ Success', 'Category "' + categoryName + '" created!');
                    } catch (error) {
                        showAlert('❌ Error', 'Error saving category: ' + error.message);
                    }
                } else {
                    showAlert('⚠️ Warning', `A category named "${categoryName}" already exists. Please choose a different name.`);
                }
            } else {
                showAlert('⚠️ Warning', 'Please enter a category name.');
            }
        }
        
        function manageCategories() {
            document.getElementById('manageCategoriesModal').style.display = 'flex';
            renderCategoriesList();
        }
        
        function closeManageCategoriesModal() {
            document.getElementById('manageCategoriesModal').style.display = 'none';
        }
        
        function deleteCategory(categoryName, fromContextMenu = false) {
            if (!fromContextMenu) {
                closeManageCategoriesModal();
            }
            
            const noteCount = notes.filter(note => note.category === categoryName).length;
            const childCategories = categories.filter(cat => cat.parent === categoryName);
            const affectedNotes = notes.filter(note => note.category === categoryName);
            
            let messageHtml = `
                <div class="delete-warning">
                    <div class="warning-icon">⚠️</div>
                    <div class="warning-text">
                        <strong>Delete "${categoryName}" category?</strong>
                        <p>This action cannot be undone.</p>
                    </div>
                </div>
                
                <div class="impact-details">
            `;
            
            if (noteCount > 0) {
                messageHtml += `
                    <div class="impact-item notes-impact">
                        <div class="impact-icon">📝</div>
                        <div class="impact-content">
                            <strong>${noteCount} note${noteCount > 1 ? 's' : ''} will be moved to "General"</strong>
                            <div class="affected-notes">
                                ${affectedNotes.slice(0, 3).map(note => `<span class="note-title">• ${note.title}</span>`).join('')}
                                ${noteCount > 3 ? `<span class="more-notes">... and ${noteCount - 3} more</span>` : ''}
                            </div>
                        </div>
                    </div>
                `;
            }
            
            if (childCategories.length > 0) {
                messageHtml += `
                    <div class="impact-item subcategories-impact">
                        <div class="impact-icon">📁</div>
                        <div class="impact-content">
                            <strong>${childCategories.length} subcategor${childCategories.length > 1 ? 'ies' : 'y'} will become root categor${childCategories.length > 1 ? 'ies' : 'y'}</strong>
                            <div class="affected-categories">
                                ${childCategories.map(cat => `<span class="category-name" style="color: ${cat.color}">• ${cat.name}</span>`).join('')}
                            </div>
                        </div>
                    </div>
                `;
            }
            
            if (noteCount === 0 && childCategories.length === 0) {
                messageHtml += `
                    <div class="impact-item safe-delete">
                        <div class="impact-icon">✅</div>
                        <div class="impact-content">
                            <strong>Safe to delete</strong>
                            <p>This category is empty and has no subcategories.</p>
                        </div>
                    </div>
                `;
            }
            
            messageHtml += '</div>';
            
            document.getElementById('deleteCategoryMessage').innerHTML = messageHtml;
            document.getElementById('confirmDeleteBtn').onclick = () => confirmDeleteCategory(categoryName, fromContextMenu);
            document.getElementById('deleteCategoryModal').style.display = 'flex';
        }
        
        async function confirmDeleteCategory(categoryName, fromContextMenu = false) {
            try {
                await ipcRenderer.invoke('db-delete-category', categoryName);
                categories = await ipcRenderer.invoke('db-get-categories');
                notes = await ipcRenderer.invoke('db-get-notes');
                updateCategorySelector();
                updateNotesList();
                renderCategoriesList();
                closeDeleteCategoryModal();
                if (fromContextMenu) {
                    showAlert('✅ Success', 'Category deleted successfully.');
                } else {
                    showAlert('✅ Success', 'Category deleted successfully.', () => {
                        document.getElementById('manageCategoriesModal').style.display = 'flex';
                    });
                }
            } catch (error) {
                showAlert('❌ Error', 'Error deleting category: ' + error.message);
            }
        }
        
        function closeDeleteCategoryModal() {
            document.getElementById('deleteCategoryModal').style.display = 'none';
        }
        
        function renderCategoriesList() {
            const categoriesList = document.getElementById('categoriesList');
            
            categoriesList.innerHTML = categories.map(cat => {
                const noteCount = notes.filter(note => note.category === cat.name).length;
                return `
                    <div class="category-item" style="border-left-color: ${cat.color};">
                        <div class="category-info">
                            <span>${cat.name}</span>
                            <span style="color: #888;">(${cat.color}) - ${noteCount} notes</span>
                        </div>
                        ${cat.name !== 'General' ? 
                            `<button class="category-delete" onclick="deleteCategory('${cat.name}')">
                                <span>🗑️</span>
                                <span>Delete</span>
                            </button>` : 
                            '<span style="color: #888;">Default</span>'
                        }
                    </div>
                `;
            }).join('');
        }
        

        
        const defaultTemplates = {
            meeting: {
                title: 'Meeting Notes - {date}',
                content: `<h2>Meeting: [Topic]</h2>
<p><strong>Date:</strong> {date}</p>
<p><strong>Attendees:</strong></p>
<ul><li></li></ul>

<h3>Agenda</h3>
<ul><li></li></ul>

<h3>Discussion Points</h3>
<ul><li></li></ul>

<h3>Action Items</h3>
<ul><li>[ ] </li></ul>

<h3>Next Steps</h3>
<p></p>`,
                tags: ['meeting', 'work'],
                displayName: 'Meeting Notes',
                isDefault: true
            },
            daily: {
                title: 'Daily Journal - {date}',
                content: `<h2>{date}</h2>

<h3>Today's Goals</h3>
<ul><li>[ ] </li></ul>

<h3>What Happened</h3>
<p></p>

<h3>Thoughts & Reflections</h3>
<p></p>

<h3>Tomorrow's Focus</h3>
<ul><li></li></ul>`,
                tags: ['journal', 'daily'],
                displayName: 'Daily Journal',
                isDefault: true
            },
            project: {
                title: 'Project: [Name]',
                content: `<h2>Project Overview</h2>
<p><strong>Start Date:</strong> {date}</p>
<p><strong>Deadline:</strong></p>
<p><strong>Status:</strong> Planning</p>

<h3>Objectives</h3>
<ul><li></li></ul>

<h3>Requirements</h3>
<ul><li></li></ul>

<h3>Tasks</h3>
<ul><li>[ ] </li></ul>

<h3>Resources</h3>
<ul><li></li></ul>

<h3>Notes</h3>
<p></p>`,
                tags: ['project', 'planning'],
                displayName: 'Project Plan',
                isDefault: true
            },
            todo: {
                title: 'To-Do List - {date}',
                content: `<h2>Tasks for {date}</h2>

<h3>High Priority</h3>
<ul><li>[ ] </li></ul>

<h3>Medium Priority</h3>
<ul><li>[ ] </li></ul>

<h3>Low Priority</h3>
<ul><li>[ ] </li></ul>

<h3>Completed</h3>
<ul><li>[x] </li></ul>`,
                tags: ['todo', 'tasks'],
                displayName: 'To-Do List',
                isDefault: true
            },
            research: {
                title: 'Research: [Topic]',
                content: `<h2>Research Topic</h2>
<p><strong>Date:</strong> {date}</p>
<p><strong>Purpose:</strong></p>

<h3>Key Questions</h3>
<ul><li></li></ul>

<h3>Sources</h3>
<ul><li></li></ul>

<h3>Findings</h3>
<p></p>

<h3>Conclusions</h3>
<p></p>

<h3>Next Steps</h3>
<ul><li></li></ul>`,
                tags: ['research', 'study'],
                displayName: 'Research Notes',
                isDefault: true
            },
            blank: {
                title: '',
                content: '',
                tags: [],
                displayName: 'Blank Note',
                isDefault: true
            }
        };
        
        let templates = { ...defaultTemplates };
        
        function showTemplateModal() {
            updateTemplateList();
            document.getElementById('templateModal').style.display = 'flex';
        }
        
        function updateTemplateList() {
            const templateList = document.getElementById('templateList');
            const templateIcons = {
                meeting: '💼',
                daily: '📅',
                project: '📁',
                todo: '✅',
                research: '🔍',
                blank: '📄'
            };
            
            templateList.innerHTML = Object.keys(templates).map(key => {
                const template = templates[key];
                const icon = templateIcons[key] || template.icon || '📄';
                return `
                    <div class="template-item" onclick="createFromTemplate('${key}')">
                        <span class="template-icon">${icon}</span>
                        <span class="template-name">${template.displayName || key}</span>
                        <div class="template-actions">
                            <button class="template-edit-btn" onclick="editTemplate('${key}'); event.stopPropagation();" title="Edit template">✏️</button>
                            <button class="template-delete-btn" onclick="deleteTemplate('${key}'); event.stopPropagation();" title="Delete template">🗑️</button>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function closeTemplateModal() {
            document.getElementById('templateModal').style.display = 'none';
        }
        
        function showAddTemplateForm() {
            editingTemplateKey = null;
            document.querySelector('#addTemplateModal h3').textContent = '➕ Create Template';
            document.querySelector('#addTemplateModal .modal-btn.save').textContent = 'Save Template';
            
            document.getElementById('templateNameInput').value = '';
            document.getElementById('templateIconInput').value = '';
            document.getElementById('templateTitleInput').value = '';
            document.getElementById('templateContentInput').value = '';
            
            document.getElementById('templateModal').style.display = 'none';
            document.getElementById('addTemplateModal').style.display = 'flex';
            document.getElementById('templateNameInput').focus();
        }
        
        function closeAddTemplateModal() {
            document.getElementById('addTemplateModal').style.display = 'none';
            document.getElementById('templateNameInput').value = '';
            document.getElementById('templateIconInput').value = '';
            document.getElementById('templateTitleInput').value = '';
            document.getElementById('templateContentInput').value = '';
        }
        
        function saveTemplate() {
            const name = document.getElementById('templateNameInput').value.trim();
            const icon = document.getElementById('templateIconInput').value.trim() || '📄';
            const title = document.getElementById('templateTitleInput').value.trim();
            const content = document.getElementById('templateContentInput').value.trim();
            
            if (!name) {
                showAlert('⚠️ Warning', 'Please enter a template name.');
                return;
            }
            
            const isEditing = editingTemplateKey !== null;
            const templateKey = isEditing ? editingTemplateKey : name.toLowerCase().replace(/\s+/g, '_');
            
            templates[templateKey] = {
                title: title || name,
                content: content,
                tags: templates[templateKey]?.tags || [],
                displayName: name,
                icon: icon,
                isDefault: templates[templateKey]?.isDefault || false
            };
            
            closeAddTemplateModal();
            const action = isEditing ? 'updated' : 'created';
            showAlert('✅ Success', `Template "${name}" ${action}!`, () => {
                showTemplateModal();
            });
            
            editingTemplateKey = null;
        }
        
        function deleteTemplate(templateKey) {
            const template = templates[templateKey];
            if (template) {
                closeTemplateModal();
                showConfirm(
                    'Delete Template',
                    `<div class="delete-warning">
                        <div class="warning-icon">🗑️</div>
                        <div class="warning-text">
                            <strong>Delete "${template.displayName || template.title}" template?</strong>
                            <p>This template will be permanently removed.</p>
                        </div>
                    </div>`,
                    () => {
                        delete templates[templateKey];
                        showAlert('✅ Success', 'Template deleted!', () => {
                            showTemplateModal();
                        });
                    },
                    'Delete Template',
                    '🗑️'
                );
                
                // Override cancel to return to template modal
                const originalCancel = document.getElementById('confirmModal').querySelector('.modal-btn.cancel').onclick;
                document.getElementById('confirmModal').querySelector('.modal-btn.cancel').onclick = () => {
                    closeConfirmModal();
                    showTemplateModal();
                };
            }
        }
        
        function resetTemplates() {
            closeTemplateModal();
            showConfirm(
                'Reset Templates',
                `<div class="delete-warning">
                    <div class="warning-text">
                        <strong>Reset all templates to defaults?</strong>
                        <p>This will remove all custom templates and restore the original ones.</p>
                    </div>
                </div>`,
                () => {
                    templates = { ...defaultTemplates };
                    showAlert('✅ Success', 'Templates reset to defaults!', () => {
                        showTemplateModal();
                    });
                },
                'Reset Templates',
                '🔄'
            );
            
            // Override cancel to return to template modal
            const originalCancel = document.getElementById('confirmModal').querySelector('.modal-btn.cancel').onclick;
            document.getElementById('confirmModal').querySelector('.modal-btn.cancel').onclick = () => {
                closeConfirmModal();
                showTemplateModal();
            };
        }
        
        let editingTemplateKey = null;
        
        function editTemplate(templateKey) {
            const template = templates[templateKey];
            if (template) {
                editingTemplateKey = templateKey;
                
                document.getElementById('templateEditorName').value = template.displayName || template.title || templateKey;
                document.getElementById('templateEditorIcon').value = template.icon || '';
                document.getElementById('templateEditorTitle').value = template.title || '';
                document.getElementById('templateEditorContent').innerHTML = template.content || '';
                
                closeTemplateModal();
                document.getElementById('templateEditorModal').style.display = 'flex';
                document.getElementById('templateEditorName').focus();
            }
        }
        
        function closeTemplateEditor() {
            document.getElementById('templateEditorModal').style.display = 'none';
            editingTemplateKey = null;
            showTemplateModal();
        }
        
        function saveTemplateEditor() {
            const name = document.getElementById('templateEditorName').value.trim();
            const icon = document.getElementById('templateEditorIcon').value.trim() || '📄';
            const title = document.getElementById('templateEditorTitle').value.trim();
            const content = document.getElementById('templateEditorContent').innerHTML;
            
            if (!name) {
                showAlert('⚠️ Warning', 'Please enter a template name.');
                return;
            }
            
            const templateKey = editingTemplateKey;
            
            templates[templateKey] = {
                title: title || name,
                content: content,
                tags: templates[templateKey]?.tags || [],
                displayName: name,
                icon: icon,
                isDefault: templates[templateKey]?.isDefault || false
            };
            
            closeTemplateEditor();
            showAlert('✅ Success', `Template "${name}" updated!`, () => {
                showTemplateModal();
            });
            
            editingTemplateKey = null;
        }
        
        function formatTemplateText(command) {
            document.execCommand(command, false, null);
            document.getElementById('templateEditorContent').focus();
        }
        
        function formatTemplateHeading(tag) {
            document.execCommand('formatBlock', false, tag);
            document.getElementById('templateEditorContent').focus();
        }
        
        function insertTemplatePlaceholder() {
            document.execCommand('insertHTML', false, '{date}');
            document.getElementById('templateEditorContent').focus();
        }
        
        function createFromTemplate(templateType) {
            const template = templates[templateType];
            const today = new Date().toLocaleDateString();
            
            currentNote = null;
            document.getElementById('welcomeScreen').style.display = 'none';
            document.getElementById('viewer').style.display = 'none';
            document.getElementById('editor').style.display = 'flex';
            
            document.getElementById('noteTitle').value = template.title.replace('{date}', today);
            document.getElementById('noteContent').innerHTML = template.content.replace(/{date}/g, today);
            document.getElementById('noteCategory').value = '';
            document.getElementById('noteTags').value = template.tags.join(', ');
            document.getElementById('noteDescription').value = '';
            
            closeTemplateModal();
            
            setTimeout(() => {
                document.getElementById('noteContent').focus();
            }, 100);
        }
        
        function createNewNote() {
            createFromTemplate('blank');
        }
        
        let blockCounter = 0;
        
        let selectedBlock = null;
        let clickPosition = null;
        
        function createBlockAtClick(event) {
            if (event.target.classList.contains('content-grid')) {
                const grid = document.getElementById('noteContent');
                const rect = grid.getBoundingClientRect();
                clickPosition = {
                    x: event.clientX - rect.left,
                    y: event.clientY - rect.top
                };
                
                if (selectedBlock) {
                    selectedBlock.classList.remove('selected');
                }
                selectedBlock = null;
            }
        }
        
        function createBlockOnType() {
            if (clickPosition && !selectedBlock) {
                const grid = document.getElementById('noteContent');
                const block = document.createElement('div');
                block.className = 'note-block selected';
                block.style.left = clickPosition.x + 'px';
                block.style.top = clickPosition.y + 'px';
                block.innerHTML = `<textarea oninput="autoResize(this); saveBlockContent(this)" onkeydown="handleBlockKeyDown(event)" onclick="selectBlock(this.parentElement); event.stopPropagation()"></textarea>`;
                grid.appendChild(block);
                makeDraggable(block);
                selectedBlock = block;
                clickPosition = null;
                return block.querySelector('textarea');
            }
            return null;
        }
        
        function autoResize(textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = textarea.scrollHeight + 'px';
            textarea.style.width = Math.max(100, textarea.value.length * 8 + 20) + 'px';
        }
        
        function selectBlock(block) {
            if (selectedBlock) {
                selectedBlock.classList.remove('selected');
            }
            selectedBlock = block;
            block.classList.add('selected');
            block.querySelector('textarea').focus();
        }
        
        function handleBlockKeyDown(event) {
            if ((event.key === 'Delete' || event.key === 'Backspace') && event.target.value === '') {
                if (selectedBlock) {
                    selectedBlock.remove();
                    selectedBlock = null;
                }
                event.preventDefault();
            }
        }
        
        function handleKeyDown(event) {
            if (!selectedBlock && clickPosition) {
                const textarea = createBlockOnType();
                if (textarea) {
                    textarea.value = event.key;
                    autoResize(textarea);
                    event.preventDefault();
                }
            }
        }
        
        function deleteBlock(btn) {
            btn.closest('.note-block').remove();
        }
        
        function saveBlockContent(textarea) {
            // Auto-save functionality can be added here
        }
        
        function makeDraggable(element) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            element.onmousedown = dragMouseDown;
            
            function dragMouseDown(e) {
                e = e || window.event;
                if (e.target.tagName === 'TEXTAREA') return;
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
            }
            
            function elementDrag(e) {
                e = e || window.event;
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                element.style.top = (element.offsetTop - pos2) + "px";
                element.style.left = (element.offsetLeft - pos1) + "px";
            }
            
            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }
        
        async function saveCurrentNote() {
            const title = document.getElementById('noteTitle').value || 'Untitled';
            const content = document.getElementById('noteContent').innerHTML;
            const category = document.getElementById('noteCategory').value || 'General';
            let tagsInput = document.getElementById('noteTags').value.trim();
            let tags = [];
            if (tagsInput) {
                if (tagsInput.includes('#')) {
                    // Handle #tag1 #tag2 format
                    tags = tagsInput.split(/\s+/).map(t => t.replace('#', '').trim()).filter(t => t);
                } else {
                    // Handle comma-separated format
                    tags = tagsInput.split(',').map(t => t.trim()).filter(t => t);
                }
            }
            const description = document.getElementById('noteDescription').value;
            
            // Check for duplicate note title
            const existingNote = notes.find(note => 
                note.title.toLowerCase() === title.toLowerCase() && 
                (!currentNote || note.id !== currentNote.id)
            );
            
            if (existingNote) {
                showAlert('⚠️ Warning', `A note with the title "${title}" already exists. Please choose a different title.`);
                return;
            }
            
            let note;
            if (currentNote) {
                // Editing existing note
                note = {
                    ...currentNote,
                    title: title,
                    content: content,
                    category: category,
                    tags: tags,
                    description: description,
                    updatedAt: new Date().toISOString()
                };
            } else {
                // Creating new note
                note = {
                    id: Date.now().toString(),
                    title: title,
                    content: content,
                    category: category,
                    tags: tags,
                    description: description,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                };
            }
            
            try {
                await ipcRenderer.invoke('db-save-note', note);
                notes = await ipcRenderer.invoke('db-get-notes');
                
                currentNote = note;
                updateNotesList();
                
                document.getElementById('editor').style.display = 'none';
                document.getElementById('viewer').style.display = 'flex';
                
                // Update viewer with processed links
                viewNote(note.id);
                
                // Also update the notes list to refresh any links there
                updateNotesList();
                
                showAlert('✅ Success', 'Note "' + title + '" saved!');
            } catch (error) {
                showAlert('❌ Error', 'Error saving note: ' + error.message);
            }
        }
        
        function cancelEdit() {
            document.getElementById('editor').style.display = 'none';
            if (currentNote) {
                document.getElementById('viewer').style.display = 'flex';
            } else {
                document.getElementById('welcomeScreen').style.display = 'flex';
            }
        }
        
        let currentVersion = 'Unknown';
        let latestVersion = 'Unknown';
        
        // Get current version from main process
        async function getCurrentVersion() {
            try {
                currentVersion = await ipcRenderer.invoke('get-app-version');
                return currentVersion;
            } catch (error) {
                console.error('Error getting app version:', error);
                return 'Unknown';
            }
        }
        
        // Setup IPC listeners for update events
        ipcRenderer.on('update-checking', () => {
            document.getElementById('updateBtn').textContent = 'Checking...';
            document.getElementById('updateBtn').disabled = true;
        });
        
        ipcRenderer.on('update-available', (event, version) => {
            latestVersion = version;
            document.getElementById('currentVersionText').textContent = currentVersion;
            document.getElementById('latestVersionText').textContent = latestVersion;
            document.getElementById('updateAvailableModal').style.display = 'flex';
            document.getElementById('updateBtn').textContent = 'Check Updates';
            document.getElementById('updateBtn').disabled = false;
        });
        
        ipcRenderer.on('update-not-available', () => {
            showAlert('✅ Up to Date', 'You have the latest version!');
            document.getElementById('updateBtn').textContent = 'Check Updates';
            document.getElementById('updateBtn').disabled = false;
        });
        
        ipcRenderer.on('update-error', (event, error) => {
            showAlert('❌ Error', 'Update error: ' + error);
            document.getElementById('updateBtn').textContent = 'Check Updates';
            document.getElementById('updateBtn').disabled = false;
        });
        
        ipcRenderer.on('update-progress', (event, percent) => {
            document.getElementById('updateProgress').style.display = 'block';
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressText').textContent = `Downloading... ${Math.round(percent)}%`;
        });
        
        ipcRenderer.on('update-downloaded', () => {
            document.getElementById('updateProgress').style.display = 'none';
            document.getElementById('installUpdateBtn').textContent = 'Restart & Install';
            document.getElementById('installUpdateBtn').disabled = false;
            showAlert('✅ Download Complete', 'Update downloaded! Click "Restart & Install" to apply the update.');
        });
        
        async function checkForUpdates() {
            await getCurrentVersion();
            await ipcRenderer.invoke('check-for-updates');
        }
        
        function closeUpdateAvailableModal() {
            document.getElementById('updateAvailableModal').style.display = 'none';
        }
        
        async function installUpdate() {
            const installBtn = document.getElementById('installUpdateBtn');
            installBtn.disabled = true;
            installBtn.textContent = 'Installing...';
            
            await ipcRenderer.invoke('install-update');
        }
        

        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initApp();
            initSearchListeners();
            setupNoteLinking();
            setupNoteLinkClicks();
        });
        
        // Listen for global shortcuts
        ipcRenderer.on('shortcut-new-note', () => {
            createNewNote();
        });
        
        ipcRenderer.on('shortcut-focus-search', () => {
            document.getElementById('searchInput').focus();
            document.getElementById('searchInput').select();
        });
        
        // Add search functionality
        document.getElementById('searchInput').addEventListener('input', updateNotesList);
        
        // Rich text formatting functions
        function formatText(command) {
            document.execCommand(command, false, null);
            document.getElementById('noteContent').focus();
        }
        
        function formatHeading(tag) {
            document.execCommand('formatBlock', false, tag);
            document.getElementById('noteContent').focus();
        }
        
        function formatCode() {
            const selection = window.getSelection();
            if (selection.toString()) {
                document.execCommand('insertHTML', false, `<code>${selection.toString()}</code>`);
            } else {
                document.execCommand('insertHTML', false, '<code></code>');
            }
            document.getElementById('noteContent').focus();
        }
        
        function highlightText() {
            document.execCommand('hiliteColor', false, '#ffff00');
            document.getElementById('noteContent').focus();
        }
        
        function alignText(alignment) {
            document.execCommand('justify' + alignment.charAt(0).toUpperCase() + alignment.slice(1), false, null);
            document.getElementById('noteContent').focus();
        }
        
        function undoRedo(action) {
            document.execCommand(action, false, null);
            document.getElementById('noteContent').focus();
        }
        
        function insertLineBreak() {
            document.execCommand('insertHTML', false, '<hr>');
            document.getElementById('noteContent').focus();
        }
        
        function formatCode() {
            document.execCommand('insertHTML', false, '<code>code</code>');
            document.getElementById('noteContent').focus();
        }
        
        function formatCodeBlock() {
            document.execCommand('insertHTML', false, '<pre><code></code></pre><p>&nbsp;</p>');
            document.getElementById('noteContent').focus();
        }
        
        function formatHeading(tag) {
            document.execCommand('formatBlock', false, tag);
            document.getElementById('noteContent').focus();
        }
        

        
        // Search highlighting function
        function highlightSearchTerm(text) {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            if (!searchTerm) return text;
            
            const regex = new RegExp(`(${searchTerm})`, 'gi');
            return text.replace(regex, '<mark style="background: #ffff00; color: #000;">$1</mark>');
        }
        
        // Sorting function
        async function changeSorting() {
            const sortBy = document.getElementById('sortSelector').value;
            notes = await ipcRenderer.invoke('db-get-notes-sorted', sortBy);
            updateNotesList();
        }
        
        // Pin toggle function
        async function togglePin(noteId) {
            try {
                await ipcRenderer.invoke('db-toggle-pin-note', noteId);
                notes = await ipcRenderer.invoke('db-get-notes');
                updateNotesList();
            } catch (error) {
                showAlert('❌ Error', 'Error toggling pin: ' + error.message);
            }
        }
        
        // In-note search variables
        let currentMatches = [];
        let currentMatchIndex = -1;
        let originalContent = '';
        
        // Floating search functions
        function openInNoteSearch() {
            const isViewer = document.getElementById('viewer').style.display !== 'none';
            const isEditor = document.getElementById('editor').style.display !== 'none';
            
            if (isViewer || isEditor) {
                const contentElement = isViewer ? document.getElementById('viewerContent') : document.getElementById('noteContent');
                const floatingSearch = document.getElementById('floatingSearch');
                const floatingSearchInput = document.getElementById('floatingSearchInput');
                
                if (contentElement && floatingSearch && floatingSearchInput) {
                    originalContent = contentElement.innerHTML;
                    floatingSearch.style.display = 'flex';
                    floatingSearchInput.focus();
                    floatingSearchInput.value = '';
                    document.getElementById('floatingSearchResults').textContent = '';
                }
            }
        }
        
        function closeFloatingSearch() {
            const floatingSearch = document.getElementById('floatingSearch');
            const floatingSearchInput = document.getElementById('floatingSearchInput');
            const isViewer = document.getElementById('viewer').style.display !== 'none';
            const contentElement = isViewer ? document.getElementById('viewerContent') : document.getElementById('noteContent');
            
            if (floatingSearch) floatingSearch.style.display = 'none';
            if (floatingSearchInput) floatingSearchInput.value = '';
            if (originalContent && contentElement) {
                contentElement.innerHTML = originalContent;
            }
            document.getElementById('floatingSearchResults').textContent = '';
            
            currentMatches = [];
            currentMatchIndex = -1;
        }
        
        function navigateSearch(direction) {
            const searchTerm = document.getElementById('floatingSearchInput').value;
            if (!searchTerm) return;
            
            const isViewer = document.getElementById('viewer').style.display !== 'none';
            const contentElement = isViewer ? document.getElementById('viewerContent') : document.getElementById('noteContent');
            searchInContent(contentElement, searchTerm, direction, 'floatingSearchResults');
        }
        
        function searchInContent(contentElement, searchTerm, direction, resultsId) {
            if (!searchTerm) {
                contentElement.innerHTML = originalContent;
                currentMatches = [];
                currentMatchIndex = -1;
                document.getElementById(resultsId).textContent = '';
                return;
            }
            
            // If this is navigation, just update which match is current
            if (direction && currentMatches.length > 0) {
                if (direction === 'next') {
                    currentMatchIndex = (currentMatchIndex + 1) % currentMatches.length;
                } else if (direction === 'prev') {
                    currentMatchIndex = currentMatchIndex <= 0 ? currentMatches.length - 1 : currentMatchIndex - 1;
                }
                
                // Remove current highlighting
                contentElement.querySelectorAll('.current-match').forEach(el => {
                    el.className = 'search-match';
                    el.removeAttribute('id');
                });
                
                // Highlight new current match
                const allMatches = contentElement.querySelectorAll('.search-match');
                if (allMatches[currentMatchIndex]) {
                    allMatches[currentMatchIndex].className = 'current-match';
                    allMatches[currentMatchIndex].id = 'current-search-match';
                    allMatches[currentMatchIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
                
                document.getElementById(resultsId).textContent = `${currentMatchIndex + 1} of ${currentMatches.length}`;
                return;
            }
            
            // Initial search
            contentElement.innerHTML = originalContent;
            
            const textContent = contentElement.textContent || contentElement.innerText || '';
            const escapedTerm = searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const textMatches = [...textContent.matchAll(new RegExp(escapedTerm, 'gi'))];
            
            if (textMatches.length === 0) {
                document.getElementById(resultsId).textContent = 'No matches';
                return;
            }
            
            currentMatches = textMatches;
            currentMatchIndex = 0;
            
            // Get all text nodes and replace matches
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = originalContent;
            
            let matchIndex = 0;
            const walker = document.createTreeWalker(
                tempDiv,
                NodeFilter.SHOW_TEXT
            );
            
            const textNodes = [];
            let node;
            while (node = walker.nextNode()) {
                textNodes.push(node);
            }
            
            textNodes.forEach(textNode => {
                const text = textNode.textContent;
                if (new RegExp(escapedTerm, 'i').test(text)) {
                    const highlightedText = text.replace(new RegExp(escapedTerm, 'gi'), (match) => {
                        const className = matchIndex === 0 ? 'current-match' : 'search-match';
                        const id = matchIndex === 0 ? 'current-search-match' : '';
                        matchIndex++;
                        return `<span class="${className}" ${id ? `id="${id}"` : ''}>${match}</span>`;
                    });
                    
                    const wrapper = document.createElement('div');
                    wrapper.innerHTML = highlightedText;
                    
                    while (wrapper.firstChild) {
                        textNode.parentNode.insertBefore(wrapper.firstChild, textNode);
                    }
                    textNode.parentNode.removeChild(textNode);
                }
            });
            
            const highlightedHTML = tempDiv.innerHTML;
            
            contentElement.innerHTML = highlightedHTML;
            
            // Scroll to first match
            const firstMatch = document.getElementById('current-search-match');
            if (firstMatch) {
                firstMatch.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
            
            document.getElementById(resultsId).textContent = `1 of ${textMatches.length}`;
        }
        
        // Global keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Only handle shortcuts if no modal is open
            const modalsOpen = document.querySelectorAll('.modal[style*="flex"]').length > 0;
            if (modalsOpen) return;
            
            const isViewer = document.getElementById('viewer').style.display !== 'none';
            const isEditor = document.getElementById('editor').style.display !== 'none';
            
            // Ctrl+S - Save note
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                if (isEditor) {
                    saveCurrentNote();
                }
            }
            
            // Ctrl+N - New note
            if (e.ctrlKey && e.key === 'n') {
                e.preventDefault();
                createNewNote();
            }
            
            // Ctrl+F - Focus search or in-note search
            if (e.ctrlKey && e.key === 'f') {
                e.preventDefault();
                if (isViewer || isEditor) {
                    openInNoteSearch();
                } else {
                    document.getElementById('searchInput').focus();
                    document.getElementById('searchInput').select();
                }
            }
            
            // Ctrl+R - Refresh/reload data
            if (e.ctrlKey && e.key === 'r') {
                e.preventDefault();
                location.reload();
            }
            
            // Escape - Close floating search
            if (e.key === 'Escape') {
                if (document.getElementById('floatingSearch').style.display !== 'none') {
                    closeFloatingSearch();
                }
            }
        });
        

        
        // Initialize floating search listener
        function initSearchListeners() {
            const floatingSearchInput = document.getElementById('floatingSearchInput');
            
            if (floatingSearchInput) {
                floatingSearchInput.addEventListener('input', function() {
                    const searchTerm = this.value.trim();
                    const isViewer = document.getElementById('viewer').style.display !== 'none';
                    const contentElement = isViewer ? document.getElementById('viewerContent') : document.getElementById('noteContent');
                    
                    if (searchTerm && contentElement) {
                        searchInContent(contentElement, searchTerm, null, 'floatingSearchResults');
                    } else if (contentElement && originalContent) {
                        contentElement.innerHTML = originalContent;
                        document.getElementById('floatingSearchResults').textContent = '';
                    }
                });
            }
        }
        
        // Drag and drop functions
        let draggedNoteId = null;
        
        function handleNoteDragStart(event) {
            draggedNoteId = event.target.dataset.noteId;
            event.target.classList.add('dragging');
        }
        
        function handleNoteDragEnd(event) {
            event.target.classList.remove('dragging');
            draggedNoteId = null;
        }
        
        function handleCategoryDragOver(event) {
            event.preventDefault();
            event.currentTarget.classList.add('drag-over');
        }
        
        function handleCategoryDragLeave(event) {
            event.currentTarget.classList.remove('drag-over');
        }
        
        async function handleCategoryDrop(event, categoryName) {
            event.preventDefault();
            event.currentTarget.classList.remove('drag-over');
            
            if (draggedNoteId && categoryName) {
                const note = notes.find(n => n.id === draggedNoteId);
                if (note && note.category !== categoryName) {
                    note.category = categoryName;
                    note.updatedAt = new Date().toISOString();
                    
                    try {
                        await ipcRenderer.invoke('db-save-note', note);
                        notes = await ipcRenderer.invoke('db-get-notes');
                        updateNotesList();
                        updateCategorySelector();
                        showAlert('✅ Success', `Note moved to ${categoryName}`);
                    } catch (error) {
                        showAlert('❌ Error', 'Error moving note: ' + error.message);
                    }
                }
            }
        }
        
        // Note linking improvements
        let linkSuggestionDiv = null;
        let selectedSuggestionIndex = -1;
        let currentSuggestions = [];
        
        function setupNoteLinking() {
            const noteContent = document.getElementById('noteContent');
            if (noteContent) {
                noteContent.addEventListener('input', handleNoteLinkInput);
                noteContent.addEventListener('keydown', function(e) {
                    if (linkSuggestionDiv && linkSuggestionDiv.style.display === 'block') {
                        if (e.key === 'ArrowDown') {
                            e.preventDefault();
                            selectedSuggestionIndex = (selectedSuggestionIndex + 1) % currentSuggestions.length;
                            updateSuggestionSelection();
                        } else if (e.key === 'ArrowUp') {
                            e.preventDefault();
                            selectedSuggestionIndex = selectedSuggestionIndex <= 0 ? currentSuggestions.length - 1 : selectedSuggestionIndex - 1;
                            updateSuggestionSelection();
                        } else if ((e.key === 'Enter' || e.key === 'Tab') && selectedSuggestionIndex >= 0) {
                            e.preventDefault();
                            e.stopPropagation();
                            insertNoteLink(currentSuggestions[selectedSuggestionIndex].title);
                        } else if (e.key === 'Escape') {
                            e.preventDefault();
                            hideLinkSuggestions();
                        }
                    }
                });
            }
        }
        
        function handleNoteLinkInput(event) {
            const selection = window.getSelection();
            if (selection.rangeCount === 0) return;
            
            const range = selection.getRangeAt(0);
            const textContent = range.startContainer.textContent || '';
            const cursorPos = range.startOffset;
            
            const beforeCursor = textContent.substring(0, cursorPos);
            const linkMatch = beforeCursor.match(/@([\w\s-]*)$/);
            
            if (linkMatch) {
                const searchTerm = linkMatch[1].toLowerCase();
                showLinkSuggestions(searchTerm, range);
            } else {
                hideLinkSuggestions();
            }
        }
        
        function showLinkSuggestions(searchTerm, range) {
            currentSuggestions = notes.filter(note => 
                (searchTerm === '' || note.title.toLowerCase().includes(searchTerm)) && 
                (!currentNote || note.id !== currentNote.id)
            ).slice(0, 8);
            
            if (currentSuggestions.length === 0) {
                hideLinkSuggestions();
                return;
            }
            
            selectedSuggestionIndex = 0;
            
            if (!linkSuggestionDiv) {
                linkSuggestionDiv = document.createElement('div');
                linkSuggestionDiv.className = 'link-suggestion';
                document.body.appendChild(linkSuggestionDiv);
            }
            
            const rect = range.getBoundingClientRect();
            linkSuggestionDiv.style.left = rect.left + 'px';
            linkSuggestionDiv.style.top = (rect.bottom + 5) + 'px';
            linkSuggestionDiv.style.display = 'block';
            
            updateSuggestionSelection();
        }
        
        function updateSuggestionSelection() {
            linkSuggestionDiv.innerHTML = currentSuggestions.map((note, index) => {
                const category = categories.find(cat => cat.name === note.category) || { color: '#4a9eff' };
                return `<div class="link-suggestion-item ${index === selectedSuggestionIndex ? 'selected' : ''}" onclick="event.stopPropagation(); insertNoteLink('${note.title.replace(/'/g, "\\'")}')"; return false;">
                    <div class="suggestion-title">${note.title}</div>
                    <div class="suggestion-meta" style="color: ${category.color}">${note.category}</div>
                </div>`;
            }).join('');
        }
        
        function hideLinkSuggestions() {
            if (linkSuggestionDiv) {
                linkSuggestionDiv.style.display = 'none';
            }
            selectedSuggestionIndex = -1;
            currentSuggestions = [];
        }
        
        function insertNoteLink(noteTitle) {
            const editor = document.getElementById('noteContent');
            const selection = window.getSelection();
            
            if (selection.rangeCount === 0) {
                hideLinkSuggestions();
                return;
            }
            
            const range = selection.getRangeAt(0);
            const textNode = range.startContainer;
            const cursorPos = range.startOffset;
            
            if (textNode.nodeType === Node.TEXT_NODE) {
                const text = textNode.textContent;
                const beforeCursor = text.substring(0, cursorPos);
                const linkMatch = beforeCursor.match(/@([\w\s-]*)$/);
                
                if (linkMatch) {
                    const startPos = cursorPos - linkMatch[0].length;
                    const beforeLink = text.substring(0, startPos);
                    const afterCursor = text.substring(cursorPos);
                    
                    textNode.textContent = beforeLink + `@${noteTitle} ` + afterCursor;
                    
                    // Set cursor after the inserted link
                    const newPos = startPos + `@${noteTitle} `.length;
                    range.setStart(textNode, newPos);
                    range.setEnd(textNode, newPos);
                    selection.removeAllRanges();
                    selection.addRange(range);
                }
            }
            
            hideLinkSuggestions();
            editor.focus();
        }
        
        // Setup click handlers for note links
        function setupNoteLinkClicks() {
            document.addEventListener('click', function(event) {
                if (event.target.classList.contains('note-link') && event.target.getAttribute('data-note-id')) {
                    event.preventDefault();
                    event.stopPropagation();
                    const noteId = event.target.getAttribute('data-note-id');
                    viewNote(noteId);
                }
            });
        }
        
        // Category context menu functions
        let contextCategoryName = null;
        
        window.showCategoryContextMenu = function(event, categoryName) {
            event.preventDefault();
            event.stopPropagation();
            
            if (categoryName === 'General') return;
            
            contextCategoryName = categoryName;
            const categoryContextMenu = document.getElementById('categoryContextMenu');
            
            if (categoryContextMenu) {
                // Show menu temporarily to get its dimensions
                categoryContextMenu.style.display = 'block';
                categoryContextMenu.style.visibility = 'hidden';
                
                const menuRect = categoryContextMenu.getBoundingClientRect();
                const windowHeight = window.innerHeight;
                const windowWidth = window.innerWidth;
                
                let left = event.pageX;
                let top = event.pageY;
                
                // Check if menu would go off the bottom of the screen
                if (event.clientY + menuRect.height > windowHeight) {
                    top = event.pageY - menuRect.height;
                }
                
                // Check if menu would go off the right of the screen
                if (event.clientX + menuRect.width > windowWidth) {
                    left = event.pageX - menuRect.width;
                }
                
                categoryContextMenu.style.left = left + 'px';
                categoryContextMenu.style.top = top + 'px';
                categoryContextMenu.style.visibility = 'visible';
                
                setTimeout(() => {
                    document.addEventListener('click', hideCategoryContextMenu, { once: true });
                }, 0);
            }
        };
        
        function hideCategoryContextMenu() {
            document.getElementById('categoryContextMenu').style.display = 'none';
            contextCategoryName = null;
        }
        
        function contextEditCategory() {
            if (contextCategoryName) {
                const category = categories.find(cat => cat.name === contextCategoryName);
                if (category) {
                    editingCategory = contextCategoryName;
                    document.getElementById('categoryModalTitle').textContent = '✏️ Edit Category';
                    document.getElementById('categorySaveBtn').textContent = 'Update';
                    document.getElementById('categoryNameInput').value = category.name;
                    document.getElementById('categoryColorInput').value = category.color;
                    
                    const buildHierarchicalOptions = (parentName = null, level = 0) => {
                        const children = categories.filter(cat => cat.parent === parentName && cat.name !== contextCategoryName);
                        let options = '';
                        children.forEach(cat => {
                            const indent = '\u00A0\u00A0\u00A0'.repeat(level);
                            options += `<option value="${cat.name}">${indent}${cat.name}</option>`;
                            options += buildHierarchicalOptions(cat.name, level + 1);
                        });
                        return options;
                    };
                    
                    const parentSelect = document.getElementById('parentCategoryInput');
                    parentSelect.innerHTML = '<option value="">No parent (root category)</option>' + buildHierarchicalOptions();
                    parentSelect.value = category.parent || '';
                    
                    document.getElementById('categoryModal').style.display = 'flex';
                    document.getElementById('categoryNameInput').focus();
                }
            }
            hideCategoryContextMenu();
        }
        
        function contextCreateSubcategory() {
            if (contextCategoryName) {
                editingCategory = null;
                document.getElementById('categoryModalTitle').textContent = '📁 Add Subcategory';
                document.getElementById('categorySaveBtn').textContent = 'Create';
                document.getElementById('categoryNameInput').value = '';
                document.getElementById('categoryColorInput').value = '#4a9eff';
                
                const buildHierarchicalOptions = (parentName = null, level = 0) => {
                    const children = categories.filter(cat => cat.parent === parentName);
                    let options = '';
                    children.forEach(cat => {
                        const indent = '\u00A0\u00A0\u00A0'.repeat(level);
                        options += `<option value="${cat.name}">${indent}${cat.name}</option>`;
                        options += buildHierarchicalOptions(cat.name, level + 1);
                    });
                    return options;
                };
                
                const parentSelect = document.getElementById('parentCategoryInput');
                parentSelect.innerHTML = '<option value="">No parent (root category)</option>' + buildHierarchicalOptions();
                parentSelect.value = contextCategoryName;
                
                document.getElementById('categoryModal').style.display = 'flex';
                document.getElementById('categoryNameInput').focus();
            }
            hideCategoryContextMenu();
        }
        
        function contextDeleteCategory() {
            if (contextCategoryName) {
                deleteCategory(contextCategoryName, true); // true = from context menu
            }
            hideCategoryContextMenu();
        }
        
        // Note context menu functions
        let contextNoteId = null;
        
        function showNoteContextMenu(event, noteId) {
            event.preventDefault();
            event.stopPropagation();
            
            contextNoteId = noteId;
            const noteContextMenu = document.getElementById('noteContextMenu');
            
            if (noteContextMenu) {
                // Show menu temporarily to get its dimensions
                noteContextMenu.style.display = 'block';
                noteContextMenu.style.visibility = 'hidden';
                
                const menuRect = noteContextMenu.getBoundingClientRect();
                const windowHeight = window.innerHeight;
                const windowWidth = window.innerWidth;
                
                let left = event.pageX;
                let top = event.pageY;
                
                // Check if menu would go off the bottom of the screen
                if (event.clientY + menuRect.height > windowHeight) {
                    top = event.pageY - menuRect.height;
                }
                
                // Check if menu would go off the right of the screen
                if (event.clientX + menuRect.width > windowWidth) {
                    left = event.pageX - menuRect.width;
                }
                
                noteContextMenu.style.left = left + 'px';
                noteContextMenu.style.top = top + 'px';
                noteContextMenu.style.visibility = 'visible';
                
                setTimeout(() => {
                    document.addEventListener('click', hideNoteContextMenu, { once: true });
                }, 0);
            }
        }
        
        function hideNoteContextMenu() {
            document.getElementById('noteContextMenu').style.display = 'none';
            contextNoteId = null;
        }
        
        function contextEditNote() {
            if (contextNoteId) {
                viewNote(contextNoteId);
                setTimeout(() => editNote(), 100);
            }
            hideNoteContextMenu();
        }
        
        function contextMoveNote() {
            if (contextNoteId) {
                currentNote = notes.find(n => n.id === contextNoteId);
                moveNoteToCategory();
            }
            hideNoteContextMenu();
        }
        
        function contextPinNote() {
            if (contextNoteId) {
                togglePin(contextNoteId);
            }
            hideNoteContextMenu();
        }
        
        function contextDeleteNote() {
            if (contextNoteId) {
                currentNote = notes.find(n => n.id === contextNoteId);
                deleteNote();
            }
            hideNoteContextMenu();
        }
        
        // Category drag and drop reordering
        let draggedCategoryName = null;
        
        function handleCategoryDragStart(event) {
            const categoryItem = event.target.closest('.category-item');
            draggedCategoryName = categoryItem.dataset.categoryName;
            categoryItem.classList.add('dragging');
            event.dataTransfer.effectAllowed = 'move';
        }
        
        function handleCategoryDragEnd(event) {
            const categoryItem = event.target.closest('.category-item');
            categoryItem.classList.remove('dragging');
            draggedCategoryName = null;
            // Remove all drag-over indicators
            document.querySelectorAll('.category-item').forEach(item => {
                item.classList.remove('drag-over-reorder');
            });
        }
        
        function handleCategoryReorderDragOver(event) {
            if (!draggedCategoryName) return;
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
            
            const targetCategoryName = event.currentTarget.dataset.categoryName;
            if (targetCategoryName && targetCategoryName !== draggedCategoryName) {
                event.currentTarget.classList.add('drag-over-reorder');
            }
        }
        
        async function handleCategoryReorderDrop(event) {
            event.preventDefault();
            event.currentTarget.classList.remove('drag-over-reorder');
            
            const targetCategoryName = event.currentTarget.dataset.categoryName;
            
            if (draggedCategoryName && targetCategoryName && draggedCategoryName !== targetCategoryName) {
                // Find the categories in the array
                const draggedIndex = categories.findIndex(cat => cat.name === draggedCategoryName);
                const targetIndex = categories.findIndex(cat => cat.name === targetCategoryName);
                
                if (draggedIndex !== -1 && targetIndex !== -1) {
                    // Swap the categories in the array
                    const draggedCategory = categories[draggedIndex];
                    categories.splice(draggedIndex, 1);
                    categories.splice(targetIndex, 0, draggedCategory);
                    
                    // Update the display
                    updateCategorySelector();
                }
            }
        }
</script>
</body>
</html>