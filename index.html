<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>MindKeep</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="app">
        <div class="app-header">
            <h1>MindKeep</h1>
            <div class="search-bar">
                <input type="text" id="searchInput" placeholder="Search notes..." class="search-input">
            </div>
            <button id="updateBtn" class="update-btn" onclick="checkForUpdates()">Check Updates</button>
        </div>
        
        <div class="app-body">
            <div class="sidebar">
                <div class="sidebar-header">
                    <select id="categorySelector" class="category-selector">
                        <option value="all">All Notes</option>
                    </select>
                    <div class="category-actions">
                        <button class="category-btn" onclick="createNewCategory()">
                            <span class="btn-icon">üé®</span>
                            <span class="btn-text">Category</span>
                        </button>
                        <button class="category-btn" onclick="manageCategories()">
                            <span class="btn-icon">‚öôÔ∏è</span>
                            <span class="btn-text">Manage</span>
                        </button>
                    </div>
                    <div class="sort-controls">
                        <select id="sortSelector" class="sort-selector" onchange="changeSorting()">
                            <option value="updated_at DESC">Recently Modified</option>
                            <option value="created_at DESC">Recently Created</option>
                            <option value="title ASC">Title A-Z</option>
                            <option value="title DESC">Title Z-A</option>
                            <option value="category ASC">Category</option>
                        </select>
                    </div>
                    <div class="bulk-actions" id="bulkActions" style="display: none;" data-selected-count="0">
                        <div class="bulk-info">
                            <span class="selection-count">0 selected</span>
                            <button class="bulk-exit-btn" onclick="toggleBulkMode()" title="Exit selection mode">‚úï</button>
                        </div>
                        <div class="bulk-buttons">
                            <button class="bulk-btn delete-btn" onclick="bulkDelete()" title="Delete selected notes">
                                <span class="btn-icon">üóëÔ∏è</span>
                                <span class="btn-text">Delete</span>
                            </button>
                            <button class="bulk-btn move-btn" onclick="bulkMove()" title="Move selected notes">
                                <span class="btn-icon">üìÅ</span>
                                <span class="btn-text">Move</span>
                            </button>
                            <button class="bulk-btn duplicate-btn" onclick="findDuplicates()" title="Find duplicate notes">
                                <span class="btn-icon">üîç</span>
                                <span class="btn-text">Duplicates</span>
                            </button>
                        </div>
                    </div>
                    <div class="note-actions">
                        <button class="new-note-btn" onclick="createNewNote()">
                            <span class="btn-icon">‚úèÔ∏è</span>
                            <span class="btn-text">New Note</span>
                        </button>
                        <button class="bulk-toggle-btn" onclick="toggleBulkMode()">
                            <span class="btn-icon">‚òëÔ∏è</span>
                            <span class="btn-text">Select Multiple</span>
                        </button>
                    </div>
                </div>
                <div id="notesList" class="notes-list">
                    <div class="no-notes-message">No notes found</div>
                </div>
                <div id="notePreview" class="note-preview" style="display: none;">
                    <h4 id="previewTitle"></h4>
                    <p id="previewContent"></p>
                </div>
            </div>
            
            <div class="main-content">
                <div id="welcomeScreen" class="welcome">
                    <h2>Welcome to MindKeep</h2>
                    <p>Your offline knowledge vault</p>
                    <button class="new-note-btn" onclick="createNewNote()">Create First Note</button>
                </div>
                
                <div id="viewer" class="viewer" style="display: none;">
                    <div class="viewer-header">
                        <h1 id="viewerTitle"></h1>
                        <div class="viewer-actions">
                            <button onclick="openInNoteSearch()" class="search-btn">
                                <span class="btn-icon">üîç</span>
                                <span class="btn-text">Search</span>
                            </button>
                            <button onclick="editNote()" class="edit-btn">
                                <span class="btn-icon">‚úèÔ∏è</span>
                                <span class="btn-text">Edit</span>
                            </button>
                            <button onclick="moveNoteToCategory()" class="move-btn">
                                <span class="btn-icon">üìÅ</span>
                                <span class="btn-text">Move</span>
                            </button>
                            <button onclick="deleteNote()" class="delete-btn">
                                <span class="btn-icon">üóëÔ∏è</span>
                                <span class="btn-text">Delete</span>
                            </button>
                        </div>
                    </div>
                    <div id="viewerMeta" class="viewer-meta"></div>

                    <div id="viewerContent" class="viewer-content"></div>
                </div>
                
                <div id="editor" class="editor" style="display: none;">
                    <div class="editor-header">
                        <input type="text" id="noteTitle" class="title-input" placeholder="Note title...">
                        <div class="editor-actions">
                            <button onclick="openInNoteSearch()" class="search-btn">
                                <span class="btn-icon">üîç</span>
                                <span class="btn-text">Search</span>
                            </button>
                            <button onclick="saveCurrentNote()" class="save-btn">Save</button>
                            <button onclick="cancelEdit()" class="cancel-btn">Cancel</button>
                        </div>
                    </div>
                    <div class="editor-body">
                        <select id="noteCategory" class="tags-input">
                            <option value="">Select Category</option>
                        </select>
                        <input type="text" id="noteTags" class="tags-input" placeholder="Tags (comma separated)...">
                        <input type="text" id="noteDescription" class="tags-input" placeholder="Description...">
                        <div class="editor-toolbar">
                            <button onclick="formatText('bold')" class="toolbar-btn"><b>B</b></button>
                            <button onclick="formatText('italic')" class="toolbar-btn"><i>I</i></button>
                            <button onclick="formatText('underline')" class="toolbar-btn"><u>U</u></button>
                            <button onclick="formatText('strikeThrough')" class="toolbar-btn"><s>S</s></button>
                            <button onclick="formatHeading('h1')" class="toolbar-btn">H1</button>
                            <button onclick="formatHeading('h2')" class="toolbar-btn">H2</button>
                            <button onclick="formatHeading('h3')" class="toolbar-btn">H3</button>
                            <button onclick="formatText('insertUnorderedList')" class="toolbar-btn">‚Ä¢</button>
                            <button onclick="formatText('insertOrderedList')" class="toolbar-btn">1.</button>
                            <button onclick="formatCode()" class="toolbar-btn">&lt;/&gt;</button>
                            <button onclick="highlightText()" class="toolbar-btn">üîÜ</button>
                            <button onclick="alignText('left')" class="toolbar-btn">‚Üê</button>
                            <button onclick="alignText('center')" class="toolbar-btn">‚Üî</button>
                            <button onclick="alignText('right')" class="toolbar-btn">‚Üí</button>
                            <button onclick="undoRedo('undo')" class="toolbar-btn">‚Ü∂</button>
                            <button onclick="undoRedo('redo')" class="toolbar-btn">‚Ü∑</button>
                        </div>

                        <div id="noteContent" class="content-editor" contenteditable="true" data-placeholder="Start writing your note..."></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Category Modal -->
    <div id="categoryModal" class="modal" style="display: none;">
        <div class="modal-content">
            <h3>üé® Create New Category</h3>
            <input type="text" id="categoryNameInput" placeholder="Category name" class="modal-input">
            <select id="parentCategoryInput" class="modal-input">
                <option value="">No parent (root category)</option>
            </select>
            <input type="color" id="categoryColorInput" value="#4a9eff" class="modal-input">
            <div class="modal-buttons">
                <button onclick="saveCategoryModal()" class="modal-btn save">Create</button>
                <button onclick="closeCategoryModal()" class="modal-btn cancel">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- Delete Category Confirmation Modal -->
    <div id="deleteCategoryModal" class="modal" style="display: none;">
        <div class="modal-content delete-category-modal">
            <h3>üóëÔ∏è Delete Category</h3>
            <div id="deleteCategoryMessage" class="delete-category-content"></div>
            <div class="modal-buttons">
                <button id="confirmDeleteBtn" class="modal-btn delete-confirm">Delete Category</button>
                <button onclick="closeDeleteCategoryModal()" class="modal-btn cancel">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- Alert Modal -->
    <div id="alertModal" class="modal" style="display: none;">
        <div class="modal-content">
            <h3 id="alertTitle">‚ÑπÔ∏è Information</h3>
            <p id="alertMessage"></p>
            <div class="modal-buttons">
                <button onclick="closeAlert()" class="modal-btn save">OK</button>
            </div>
        </div>
    </div>
    
    <!-- Manage Categories Modal -->
    <div id="manageCategoriesModal" class="modal" style="display: none;">
        <div class="modal-content">
            <h3>‚öôÔ∏è Manage Categories</h3>
            <div id="categoriesList" class="categories-list"></div>
            <div class="modal-buttons">
                <button onclick="closeManageCategoriesModal()" class="modal-btn cancel">Close</button>
            </div>
        </div>
    </div>
    
    <!-- Move Note Modal -->
    <div id="moveNoteModal" class="modal" style="display: none;">
        <div class="modal-content">
            <h3>üìÅ Move Note</h3>
            <select id="moveToCategory" class="modal-input">
                <option value="">Select Category</option>
            </select>
            <div class="modal-buttons">
                <button onclick="confirmMoveNote()" class="modal-btn save">Move</button>
                <button onclick="closeMoveNoteModal()" class="modal-btn cancel">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- Bulk Move Modal -->
    <div id="bulkMoveModal" class="modal" style="display: none;">
        <div class="modal-content">
            <h3>üìÅ Move Selected Notes</h3>
            <p>Move <span id="selectedCount">0</span> selected notes to:</p>
            <select id="bulkMoveToCategory" class="modal-input">
                <option value="">Select Category</option>
            </select>
            <div class="modal-buttons">
                <button onclick="confirmBulkMove()" class="modal-btn save">Move</button>
                <button onclick="closeBulkMoveModal()" class="modal-btn cancel">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- Duplicates Modal -->
    <div id="duplicatesModal" class="modal" style="display: none;">
        <div class="modal-content">
            <h3>üîç Duplicate Notes</h3>
            <div id="duplicatesList" class="duplicates-list"></div>
            <div class="modal-buttons">
                <button onclick="closeDuplicatesModal()" class="modal-btn cancel">Close</button>
            </div>
        </div>
    </div>
    
    <!-- Confirmation Modal -->
    <div id="confirmModal" class="modal" style="display: none;">
        <div class="modal-content confirm-modal">
            <h3 id="confirmTitle">‚ö†Ô∏è Confirm Action</h3>
            <div id="confirmMessage" class="confirm-content"></div>
            <div class="modal-buttons">
                <button id="confirmYesBtn" class="modal-btn delete-confirm">Confirm</button>
                <button onclick="closeConfirmModal()" class="modal-btn cancel">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- Update Available Modal -->
    <div id="updateAvailableModal" class="modal" style="display: none;">
        <div class="modal-content">
            <h3>üéâ Update Available!</h3>
            <div class="update-info">
                <div class="version-comparison">
                    <div class="version-item">
                        <span class="version-label">Current Version:</span>
                        <span id="currentVersionText" class="version-number"></span>
                    </div>
                    <div class="version-arrow">‚Üí</div>
                    <div class="version-item">
                        <span class="version-label">Latest Version:</span>
                        <span id="latestVersionText" class="version-number"></span>
                    </div>
                </div>
                <div id="updateProgress" class="update-progress" style="display: none;">
                    <div class="progress-bar">
                        <div id="progressFill" class="progress-fill"></div>
                    </div>
                    <div id="progressText" class="progress-text">Downloading...</div>
                </div>
            </div>
            <div class="modal-buttons">
                <button id="installUpdateBtn" onclick="installUpdate()" class="modal-btn save">Install Update</button>
                <button onclick="closeUpdateAvailableModal()" class="modal-btn cancel">Later</button>
            </div>
        </div>
    </div>
    
    <!-- Floating In-Note Search -->
    <div id="floatingSearch" class="floating-search" style="display: none;">
        <input type="text" id="floatingSearchInput" placeholder="Search in note..." class="floating-search-input">
        <div class="floating-search-controls">
            <button onclick="navigateSearch('prev')" class="floating-nav-btn">‚Üë</button>
            <button onclick="navigateSearch('next')" class="floating-nav-btn">‚Üì</button>
            <span id="floatingSearchResults" class="floating-search-results"></span>
            <button onclick="closeFloatingSearch()" class="floating-close-btn">‚úï</button>
        </div>
    </div>
    
    <script>
        const { ipcRenderer } = require('electron');
        
        // App data
        let categories = [];
        let notes = [];
        
        // Initialize app
        async function initApp() {
            try {
                // Load categories from database
                categories = await ipcRenderer.invoke('db-get-categories');
                
                // Load notes from database
                notes = await ipcRenderer.invoke('db-get-notes');
                
                updateCategorySelector();
                updateNotesList();
            } catch (error) {
                console.error('Initialization error:', error);
                updateCategorySelector();
                updateNotesList();
            }
        }
        
        async function loadNotes() {
            try {
                notes = await ipcRenderer.invoke('db-get-notes');
            } catch (error) {
                console.error('Error loading notes:', error);
            }
        }
        
        let currentCategory = 'all';
        let bulkMode = false;
        let selectedNotes = new Set();
        
        function updateCategorySelector() {
            const selector = document.getElementById('categorySelector');
            const noteCategory = document.getElementById('noteCategory');
            
            const buildCategoryOptions = (cats) => {
                const rootCats = cats.filter(cat => !cat.parent);
                let options = '';
                
                rootCats.forEach(cat => {
                    options += `<option value="${cat.name}">${cat.name}</option>`;
                    const children = cats.filter(c => c.parent === cat.name);
                    children.forEach(child => {
                        options += `<option value="${child.name}">\u00A0\u00A0\u00A0\u00A0${child.name}</option>`;
                    });
                });
                
                return options;
            };
            
            const options = '<option value="all">All Notes</option>' + buildCategoryOptions(categories);
            selector.innerHTML = options;
            selector.value = currentCategory;
            
            selector.onchange = function() {
                currentCategory = this.value;
                updateNotesList();
            };
            
            const noteOptions = '<option value="">Select Category</option>' + buildCategoryOptions(categories);
            noteCategory.innerHTML = noteOptions;
        }
        
        function showPreview(event, noteId) {
            const note = notes.find(n => n.id === noteId);
            if (!note) return;
            
            const preview = document.getElementById('notePreview');
            const title = document.getElementById('previewTitle');
            const content = document.getElementById('previewContent');
            
            title.textContent = note.title;
            content.textContent = note.content ? note.content.replace(/<[^>]*>/g, '').substring(0, 150) + '...' : 'No content';
            
            preview.style.display = 'block';
            preview.style.left = event.pageX + 10 + 'px';
            preview.style.top = event.pageY + 10 + 'px';
        }
        
        function hidePreview() {
            document.getElementById('notePreview').style.display = 'none';
        }
        
        function updateNotesList() {
            const notesList = document.getElementById('notesList');
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            
            // Filter notes by selected category
            let filteredNotes = currentCategory === 'all' ? 
                notes : notes.filter(note => note.category === currentCategory);
            
            // Filter by search term
            if (searchTerm) {
                filteredNotes = filteredNotes.filter(note => 
                    note.title.toLowerCase().includes(searchTerm) ||
                    note.content.toLowerCase().includes(searchTerm) ||
                    note.description.toLowerCase().includes(searchTerm)
                );
            }
            
            if (filteredNotes.length === 0) {
                notesList.innerHTML = '<div class="no-notes-message">No notes found</div>';
                return;
            }
            
            notesList.innerHTML = filteredNotes.map(note => {
                const category = categories.find(cat => cat.name === note.category) || { color: '#4a9eff' };
                const isSelected = selectedNotes.has(note.id);
                const checkboxHtml = bulkMode ? `<input type="checkbox" ${isSelected ? 'checked' : ''} onchange="toggleNoteSelection('${note.id}')" onclick="event.stopPropagation()">` : '';
                const pinIcon = note.isPinned ? 'üìå' : '';
                
                return `
                    <div class="note-item ${isSelected ? 'selected' : ''} ${note.isPinned ? 'pinned' : ''}" style="border-left: 4px solid ${category.color}; padding: 1rem; margin-bottom: 0.5rem; background: ${isSelected ? '#555' : '#404040'}; border-radius: 4px; cursor: pointer; display: flex; align-items: center; gap: 10px;" onclick="${bulkMode ? `toggleNoteSelection('${note.id}')` : `viewNote('${note.id}')`}" onmouseenter="showPreview(event, '${note.id}')" onmouseleave="hidePreview()">
                        ${checkboxHtml}
                        <div style="flex: 1;">
                            <div style="font-weight: bold; color: #e0e0e0; display: flex; align-items: center; gap: 0.5rem;">
                                ${pinIcon}
                                <span>${highlightSearchTerm(processNoteLinks(note.title))}</span>
                            </div>
                            <div style="color: #888; font-size: 0.9rem; margin-top: 0.5rem;">${new Date(note.updatedAt).toLocaleDateString()}</div>
                        </div>
                        ${!bulkMode ? `<button class="pin-btn" onclick="togglePin('${note.id}'); event.stopPropagation();" title="${note.isPinned ? 'Unpin' : 'Pin'} note">${note.isPinned ? 'üìå' : 'üìç'}</button>` : ''}
                    </div>
                `;
            }).join('');
        }
        
        // Process note links [[Note Name]]
        function processNoteLinks(text) {
            return text.replace(/\[\[([^\]]+)\]\]/g, (match, noteName) => {
                const linkedNote = notes.find(note => note.title.toLowerCase() === noteName.toLowerCase());
                if (linkedNote) {
                    return `<span class="note-link" onclick="viewNote('${linkedNote.id}'); event.stopPropagation();" style="color: #4a9eff; cursor: pointer; text-decoration: underline;">${noteName}</span>`;
                }
                return `<span style="color: #888;">${noteName}</span>`;
            });
        }
        
        // Bulk operations
        function toggleBulkMode() {
            bulkMode = !bulkMode;
            selectedNotes.clear();
            const bulkActions = document.getElementById('bulkActions');
            const toggleBtn = document.querySelector('.bulk-toggle-btn');
            const toggleIcon = toggleBtn.querySelector('.btn-icon');
            const toggleText = toggleBtn.querySelector('.btn-text');
            
            bulkActions.style.display = bulkMode ? 'flex' : 'none';
            
            if (bulkMode) {
                toggleBtn.style.display = 'none';
            } else {
                toggleBtn.style.display = 'flex';
                toggleIcon.textContent = '‚òëÔ∏è';
                toggleText.textContent = 'Select Multiple';
                toggleBtn.style.background = 'linear-gradient(135deg, #6c757d, #5a6268)';
                toggleBtn.classList.remove('exit-mode');
            }
            
            updateNotesList();
        }
        
        function toggleNoteSelection(noteId) {
            if (selectedNotes.has(noteId)) {
                selectedNotes.delete(noteId);
            } else {
                selectedNotes.add(noteId);
            }
            
            // Update selection counter immediately
            updateSelectionCounter();
            updateNotesList();
        }
        
        function updateSelectionCounter() {
            const bulkActions = document.getElementById('bulkActions');
            const selectionCount = document.querySelector('.selection-count');
            
            if (bulkActions && selectionCount && bulkMode) {
                const count = selectedNotes.size;
                bulkActions.setAttribute('data-selected-count', count);
                selectionCount.textContent = `${count} selected`;
                
                // Enable/disable action buttons based on selection
                const actionButtons = document.querySelectorAll('.bulk-btn:not(.bulk-exit-btn)');
                actionButtons.forEach(btn => {
                    btn.disabled = count === 0;
                    btn.style.opacity = count === 0 ? '0.5' : '1';
                });
            }
        }
        
        function bulkDelete() {
            if (selectedNotes.size === 0) {
                showAlert('‚ö†Ô∏è Warning', 'No notes selected.');
                return;
            }
            
            showConfirm(
                'Delete Selected Notes',
                `<div class="delete-warning">
                    <div class="warning-icon">üóëÔ∏è</div>
                    <div class="warning-text">
                        <strong>Delete ${selectedNotes.size} selected note${selectedNotes.size > 1 ? 's' : ''}?</strong>
                        <p>This action cannot be undone.</p>
                    </div>
                </div>`,
                () => {
                selectedNotes.forEach(noteId => {
                    try {
                        const filePath = path.join(notesDir, noteId + '.json');
                        if (fs.existsSync(filePath)) {
                            fs.unlinkSync(filePath);
                        }
                        notes = notes.filter(note => note.id !== noteId);
                    } catch (error) {
                        console.error('Error deleting note:', error);
                    }
                });
                
                    selectedNotes.clear();
                    updateNotesList();
                    showAlert('‚úÖ Success', 'Selected notes deleted!');
                },
                'Delete Notes',
                'üóëÔ∏è'
            );
        }
        
        function bulkMove() {
            if (selectedNotes.size === 0) {
                showAlert('‚ö†Ô∏è Warning', 'No notes selected.');
                return;
            }
            
            document.getElementById('selectedCount').textContent = selectedNotes.size;
            const bulkMoveSelect = document.getElementById('bulkMoveToCategory');
            bulkMoveSelect.innerHTML = '<option value="">Select Category</option>' + 
                categories.map(cat => `<option value="${cat.name}">${cat.name}</option>`).join('');
            document.getElementById('bulkMoveModal').style.display = 'flex';
        }
        
        function confirmBulkMove() {
            const newCategory = document.getElementById('bulkMoveToCategory').value;
            if (!newCategory) {
                showAlert('‚ö†Ô∏è Warning', 'Please select a category.');
                return;
            }
            
            selectedNotes.forEach(noteId => {
                const note = notes.find(n => n.id === noteId);
                if (note) {
                    note.category = newCategory;
                    note.updatedAt = new Date().toISOString();
                    try {
                        const filePath = path.join(notesDir, note.id + '.json');
                        fs.writeFileSync(filePath, JSON.stringify(note, null, 2));
                    } catch (error) {
                        console.error('Error updating note:', error);
                    }
                }
            });
            
            selectedNotes.clear();
            updateNotesList();
            closeBulkMoveModal();
            showAlert('‚úÖ Success', 'Notes moved successfully!');
        }
        
        function closeBulkMoveModal() {
            document.getElementById('bulkMoveModal').style.display = 'none';
        }
        
        // Find duplicates
        function findDuplicates() {
            const duplicates = [];
            const seen = new Map();
            
            notes.forEach(note => {
                const key = note.title.toLowerCase().trim();
                if (seen.has(key)) {
                    const existing = seen.get(key);
                    if (!duplicates.find(d => d.original.id === existing.id)) {
                        duplicates.push({ original: existing, duplicates: [note] });
                    } else {
                        duplicates.find(d => d.original.id === existing.id).duplicates.push(note);
                    }
                } else {
                    seen.set(key, note);
                }
            });
            
            if (duplicates.length === 0) {
                showAlert('‚úÖ No Duplicates', 'No duplicate notes found!');
                return;
            }
            
            const duplicatesList = document.getElementById('duplicatesList');
            duplicatesList.innerHTML = duplicates.map(group => `
                <div class="duplicate-group" style="margin-bottom: 20px; padding: 15px; background: #333; border-radius: 8px;">
                    <h4 style="color: #e0e0e0; margin-bottom: 10px;">"${group.original.title}"</h4>
                    <div class="duplicate-item" style="margin-bottom: 10px; padding: 10px; background: #404040; border-radius: 4px;">
                        <strong>Original:</strong> ${new Date(group.original.createdAt).toLocaleDateString()}
                        <button onclick="viewNote('${group.original.id}'); closeDuplicatesModal();" style="margin-left: 10px;">View</button>
                    </div>
                    ${group.duplicates.map(dup => `
                        <div class="duplicate-item" style="margin-bottom: 5px; padding: 10px; background: #555; border-radius: 4px;">
                            <strong>Duplicate:</strong> ${new Date(dup.createdAt).toLocaleDateString()}
                            <button onclick="viewNote('${dup.id}'); closeDuplicatesModal();" style="margin-left: 10px;">View</button>
                            <button onclick="deleteDuplicate('${dup.id}')" style="margin-left: 5px; background: #d32f2f;">Delete</button>
                        </div>
                    `).join('')}
                </div>
            `).join('');
            
            document.getElementById('duplicatesModal').style.display = 'flex';
        }
        
        async function deleteDuplicate(noteId) {
            const note = notes.find(n => n.id === noteId);
            showConfirm(
                'Delete Duplicate Note',
                `<div class="delete-warning">
                    <div class="warning-icon">üóëÔ∏è</div>
                    <div class="warning-text">
                        <strong>Delete "${note ? note.title : 'Unknown'}"?</strong>
                        <p>This duplicate note will be permanently deleted.</p>
                        <p style="color: #888; font-size: 0.9rem; margin-top: 0.5rem;">The original note will remain untouched.</p>
                    </div>
                </div>`,
                async () => {
                    try {
                        await ipcRenderer.invoke('db-delete-note', noteId);
                        notes = await ipcRenderer.invoke('db-get-notes');
                        updateNotesList();
                        findDuplicates(); // Refresh duplicates list
                        showAlert('‚úÖ Success', 'Duplicate note deleted!');
                    } catch (error) {
                        showAlert('‚ùå Error', 'Error deleting note: ' + error.message);
                    }
                },
                'Delete Duplicate',
                'üóëÔ∏è'
            );
        }
        
        function closeDuplicatesModal() {
            document.getElementById('duplicatesModal').style.display = 'none';
        }
        
        // Move single note
        function moveNoteToCategory() {
            if (!currentNote) return;
            
            const moveSelect = document.getElementById('moveToCategory');
            moveSelect.innerHTML = '<option value="">Select Category</option>' + 
                categories.filter(cat => cat.name !== currentNote.category)
                    .map(cat => `<option value="${cat.name}">${cat.name}</option>`).join('');
            document.getElementById('moveNoteModal').style.display = 'flex';
        }
        
        function confirmMoveNote() {
            const newCategory = document.getElementById('moveToCategory').value;
            if (!newCategory) {
                showAlert('‚ö†Ô∏è Warning', 'Please select a category.');
                return;
            }
            
            currentNote.category = newCategory;
            currentNote.updatedAt = new Date().toISOString();
            
            try {
                const filePath = path.join(notesDir, currentNote.id + '.json');
                fs.writeFileSync(filePath, JSON.stringify(currentNote, null, 2));
                
                // Update in array
                const index = notes.findIndex(n => n.id === currentNote.id);
                if (index >= 0) {
                    notes[index] = currentNote;
                }
                
                updateNotesList();
                viewNote(currentNote.id); // Refresh viewer
                closeMoveNoteModal();
                showAlert('‚úÖ Success', 'Note moved successfully!');
            } catch (error) {
                showAlert('‚ùå Error', 'Error moving note: ' + error.message);
            }
        }
        
        function closeMoveNoteModal() {
            document.getElementById('moveNoteModal').style.display = 'none';
        }
        
        let currentNote = null;
        
        function viewNote(noteId) {
            currentNote = notes.find(note => note.id === noteId);
            if (currentNote) {
                document.getElementById('welcomeScreen').style.display = 'none';
                document.getElementById('editor').style.display = 'none';
                document.getElementById('viewer').style.display = 'flex';
                
                document.getElementById('viewerTitle').textContent = currentNote.title;
                document.getElementById('viewerMeta').innerHTML = `
                    <span>Category: ${currentNote.category}</span> ‚Ä¢ 
                    <span>Created: ${new Date(currentNote.createdAt).toLocaleDateString()}</span> ‚Ä¢ 
                    <span>Updated: ${new Date(currentNote.updatedAt).toLocaleDateString()}</span>
                    ${currentNote.description ? `<br><span style="color: #4a9eff; font-style: italic;">üìù ${currentNote.description}</span>` : ''}
                `;
                document.getElementById('viewerContent').innerHTML = processNoteLinks(currentNote.content) || '<em>No content</em>';
            }
        }
        
        function editNote() {
            if (currentNote) {
                document.getElementById('viewer').style.display = 'none';
                document.getElementById('editor').style.display = 'flex';
                
                document.getElementById('noteTitle').value = currentNote.title;
                document.getElementById('noteContent').innerHTML = currentNote.content || '';
                document.getElementById('noteCategory').value = currentNote.category;
                document.getElementById('noteTags').value = currentNote.tags.join(', ');
                document.getElementById('noteDescription').value = currentNote.description;
                
                // Focus the content editor
                setTimeout(() => {
                    document.getElementById('noteContent').focus();
                }, 100);
            }
        }
        
        async function deleteNote() {
            if (!currentNote) return;
            
            showConfirm(
                'Delete Note',
                `<div class="delete-warning">
                    <div class="warning-icon">üóëÔ∏è</div>
                    <div class="warning-text">
                        <strong>Delete "${currentNote.title}"?</strong>
                        <p>This note will be permanently deleted and cannot be recovered.</p>
                        <div style="margin-top: 1rem; padding: 0.5rem; background: #333; border-radius: 4px;">
                            <div style="font-size: 0.85rem; color: #bbb;">Category: ${currentNote.category}</div>
                            <div style="font-size: 0.85rem; color: #bbb;">Created: ${new Date(currentNote.createdAt).toLocaleDateString()}</div>
                        </div>
                    </div>
                </div>`,
                async () => {
                    try {
                        await ipcRenderer.invoke('db-delete-note', currentNote.id);
                        notes = await ipcRenderer.invoke('db-get-notes');
                        
                        // Update UI
                        updateNotesList();
                        
                        // Go back to welcome screen
                        document.getElementById('viewer').style.display = 'none';
                        document.getElementById('welcomeScreen').style.display = 'flex';
                        
                        currentNote = null;
                        showAlert('üóëÔ∏è Deleted', 'Note deleted successfully!');
                    } catch (error) {
                        showAlert('‚ùå Error', 'Error deleting note: ' + error.message);
                    }
                },
                'Delete Note',
                'üóëÔ∏è'
            );
        }
        
        // Modal functions
        function showAlert(title, message) {
            document.getElementById('alertTitle').textContent = title;
            document.getElementById('alertMessage').textContent = message;
            document.getElementById('alertModal').style.display = 'flex';
        }
        
        function closeAlert() {
            document.getElementById('alertModal').style.display = 'none';
        }
        
        // Enhanced confirmation modal
        function showConfirm(title, message, onConfirm, confirmText = 'Confirm', icon = '‚ö†Ô∏è') {
            document.getElementById('confirmTitle').innerHTML = `${icon} ${title}`;
            document.getElementById('confirmMessage').innerHTML = message;
            document.getElementById('confirmYesBtn').textContent = confirmText;
            document.getElementById('confirmYesBtn').onclick = () => {
                closeConfirmModal();
                onConfirm();
            };
            document.getElementById('confirmModal').style.display = 'flex';
        }
        
        function closeConfirmModal() {
            document.getElementById('confirmModal').style.display = 'none';
        }
        
        function createNewCategory() {
            const parentSelect = document.getElementById('parentCategoryInput');
            parentSelect.innerHTML = '<option value="">No parent (root category)</option>' + 
                categories.filter(cat => !cat.parent).map(cat => `<option value="${cat.name}">${cat.name}</option>`).join('');
            document.getElementById('categoryModal').style.display = 'flex';
            document.getElementById('categoryNameInput').focus();
        }
        
        function closeCategoryModal() {
            document.getElementById('categoryModal').style.display = 'none';
            document.getElementById('categoryNameInput').value = '';
            document.getElementById('categoryColorInput').value = '#4a9eff';
        }
        
        async function saveCategoryModal() {
            const categoryName = document.getElementById('categoryNameInput').value.trim();
            const parentCategory = document.getElementById('parentCategoryInput').value || null;
            const color = document.getElementById('categoryColorInput').value;
            
            if (categoryName) {
                if (!categories.find(cat => cat.name === categoryName)) {
                    try {
                        await ipcRenderer.invoke('db-add-category', categoryName, color, parentCategory);
                        categories = await ipcRenderer.invoke('db-get-categories');
                        updateCategorySelector();
                        closeCategoryModal();
                        showAlert('‚úÖ Success', 'Category "' + categoryName + '" created!');
                    } catch (error) {
                        showAlert('‚ùå Error', 'Error saving category: ' + error.message);
                    }
                } else {
                    showAlert('‚ö†Ô∏è Warning', 'Category already exists!');
                }
            } else {
                showAlert('‚ö†Ô∏è Warning', 'Please enter a category name.');
            }
        }
        
        function manageCategories() {
            document.getElementById('manageCategoriesModal').style.display = 'flex';
            renderCategoriesList();
        }
        
        function closeManageCategoriesModal() {
            document.getElementById('manageCategoriesModal').style.display = 'none';
        }
        
        function deleteCategory(categoryName) {
            const noteCount = notes.filter(note => note.category === categoryName).length;
            const childCategories = categories.filter(cat => cat.parent === categoryName);
            const affectedNotes = notes.filter(note => note.category === categoryName);
            
            let messageHtml = `
                <div class="delete-warning">
                    <div class="warning-icon">‚ö†Ô∏è</div>
                    <div class="warning-text">
                        <strong>Delete "${categoryName}" category?</strong>
                        <p>This action cannot be undone.</p>
                    </div>
                </div>
                
                <div class="impact-details">
            `;
            
            if (noteCount > 0) {
                messageHtml += `
                    <div class="impact-item notes-impact">
                        <div class="impact-icon">üìù</div>
                        <div class="impact-content">
                            <strong>${noteCount} note${noteCount > 1 ? 's' : ''} will be moved to "General"</strong>
                            <div class="affected-notes">
                                ${affectedNotes.slice(0, 3).map(note => `<span class="note-title">‚Ä¢ ${note.title}</span>`).join('')}
                                ${noteCount > 3 ? `<span class="more-notes">... and ${noteCount - 3} more</span>` : ''}
                            </div>
                        </div>
                    </div>
                `;
            }
            
            if (childCategories.length > 0) {
                messageHtml += `
                    <div class="impact-item subcategories-impact">
                        <div class="impact-icon">üìÅ</div>
                        <div class="impact-content">
                            <strong>${childCategories.length} subcategor${childCategories.length > 1 ? 'ies' : 'y'} will become root categor${childCategories.length > 1 ? 'ies' : 'y'}</strong>
                            <div class="affected-categories">
                                ${childCategories.map(cat => `<span class="category-name" style="color: ${cat.color}">‚Ä¢ ${cat.name}</span>`).join('')}
                            </div>
                        </div>
                    </div>
                `;
            }
            
            if (noteCount === 0 && childCategories.length === 0) {
                messageHtml += `
                    <div class="impact-item safe-delete">
                        <div class="impact-icon">‚úÖ</div>
                        <div class="impact-content">
                            <strong>Safe to delete</strong>
                            <p>This category is empty and has no subcategories.</p>
                        </div>
                    </div>
                `;
            }
            
            messageHtml += '</div>';
            
            document.getElementById('deleteCategoryMessage').innerHTML = messageHtml;
            document.getElementById('confirmDeleteBtn').onclick = () => confirmDeleteCategory(categoryName);
            document.getElementById('deleteCategoryModal').style.display = 'flex';
        }
        
        async function confirmDeleteCategory(categoryName) {
            try {
                await ipcRenderer.invoke('db-delete-category', categoryName);
                categories = await ipcRenderer.invoke('db-get-categories');
                notes = await ipcRenderer.invoke('db-get-notes');
                updateCategorySelector();
                updateNotesList();
                renderCategoriesList();
                closeDeleteCategoryModal();
                showAlert('‚úÖ Success', 'Category deleted successfully.');
            } catch (error) {
                showAlert('‚ùå Error', 'Error deleting category: ' + error.message);
            }
        }
        
        function closeDeleteCategoryModal() {
            document.getElementById('deleteCategoryModal').style.display = 'none';
        }
        
        function renderCategoriesList() {
            const categoriesList = document.getElementById('categoriesList');
            
            categoriesList.innerHTML = categories.map(cat => {
                const noteCount = notes.filter(note => note.category === cat.name).length;
                return `
                    <div class="category-item" style="border-left-color: ${cat.color};">
                        <div class="category-info">
                            <span>${cat.name}</span>
                            <span style="color: #888;">(${cat.color}) - ${noteCount} notes</span>
                        </div>
                        ${cat.name !== 'General' ? 
                            `<button class="category-delete" onclick="deleteCategory('${cat.name}')">Delete</button>` : 
                            '<span style="color: #888;">Default</span>'
                        }
                    </div>
                `;
            }).join('');
        }
        
        function deleteCategory(categoryName) {
            if (confirm('Delete category "' + categoryName + '"? Notes will be moved to General.')) {
                // Move notes to General
                notes.forEach(note => {
                    if (note.category === categoryName) {
                        note.category = 'General';
                        try {
                            const filePath = path.join(notesDir, note.id + '.json');
                            fs.writeFileSync(filePath, JSON.stringify(note, null, 2));
                        } catch (error) {
                            console.error('Error updating note:', error);
                        }
                    }
                });
                
                // Remove category
                categories = categories.filter(cat => cat.name !== categoryName);
                try {
                    fs.writeFileSync(categoriesFile, JSON.stringify(categories, null, 2));
                    updateCategorySelector();
                    updateNotesList();
                    renderCategoriesList();
                    showAlert('‚úÖ Success', 'Category deleted and notes moved to General.');
                } catch (error) {
                    showAlert('‚ùå Error', 'Error deleting category: ' + error.message);
                }
            }
        }
        
        function createNewNote() {
            currentNote = null;
            document.getElementById('welcomeScreen').style.display = 'none';
            document.getElementById('viewer').style.display = 'none';
            document.getElementById('editor').style.display = 'flex';
            document.getElementById('noteTitle').value = '';
            document.getElementById('noteContent').innerHTML = '';
            document.getElementById('noteCategory').value = '';
            document.getElementById('noteTags').value = '';
            document.getElementById('noteDescription').value = '';
            
            // Focus the content editor
            setTimeout(() => {
                document.getElementById('noteContent').focus();
            }, 100);
        }
        
        let blockCounter = 0;
        
        let selectedBlock = null;
        let clickPosition = null;
        
        function createBlockAtClick(event) {
            if (event.target.classList.contains('content-grid')) {
                const grid = document.getElementById('noteContent');
                const rect = grid.getBoundingClientRect();
                clickPosition = {
                    x: event.clientX - rect.left,
                    y: event.clientY - rect.top
                };
                
                if (selectedBlock) {
                    selectedBlock.classList.remove('selected');
                }
                selectedBlock = null;
            }
        }
        
        function createBlockOnType() {
            if (clickPosition && !selectedBlock) {
                const grid = document.getElementById('noteContent');
                const block = document.createElement('div');
                block.className = 'note-block selected';
                block.style.left = clickPosition.x + 'px';
                block.style.top = clickPosition.y + 'px';
                block.innerHTML = `<textarea oninput="autoResize(this); saveBlockContent(this)" onkeydown="handleBlockKeyDown(event)" onclick="selectBlock(this.parentElement); event.stopPropagation()"></textarea>`;
                grid.appendChild(block);
                makeDraggable(block);
                selectedBlock = block;
                clickPosition = null;
                return block.querySelector('textarea');
            }
            return null;
        }
        
        function autoResize(textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = textarea.scrollHeight + 'px';
            textarea.style.width = Math.max(100, textarea.value.length * 8 + 20) + 'px';
        }
        
        function selectBlock(block) {
            if (selectedBlock) {
                selectedBlock.classList.remove('selected');
            }
            selectedBlock = block;
            block.classList.add('selected');
            block.querySelector('textarea').focus();
        }
        
        function handleBlockKeyDown(event) {
            if ((event.key === 'Delete' || event.key === 'Backspace') && event.target.value === '') {
                if (selectedBlock) {
                    selectedBlock.remove();
                    selectedBlock = null;
                }
                event.preventDefault();
            }
        }
        
        function handleKeyDown(event) {
            if (!selectedBlock && clickPosition) {
                const textarea = createBlockOnType();
                if (textarea) {
                    textarea.value = event.key;
                    autoResize(textarea);
                    event.preventDefault();
                }
            }
        }
        
        function deleteBlock(btn) {
            btn.closest('.note-block').remove();
        }
        
        function saveBlockContent(textarea) {
            // Auto-save functionality can be added here
        }
        
        function makeDraggable(element) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            element.onmousedown = dragMouseDown;
            
            function dragMouseDown(e) {
                e = e || window.event;
                if (e.target.tagName === 'TEXTAREA') return;
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
            }
            
            function elementDrag(e) {
                e = e || window.event;
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                element.style.top = (element.offsetTop - pos2) + "px";
                element.style.left = (element.offsetLeft - pos1) + "px";
            }
            
            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }
        
        async function saveCurrentNote() {
            const title = document.getElementById('noteTitle').value || 'Untitled';
            const content = document.getElementById('noteContent').innerHTML;
            const category = document.getElementById('noteCategory').value || 'General';
            const tags = document.getElementById('noteTags').value.split(',').map(t => t.trim()).filter(t => t);
            const description = document.getElementById('noteDescription').value;
            
            let note;
            if (currentNote) {
                // Editing existing note
                note = {
                    ...currentNote,
                    title: title,
                    content: content,
                    category: category,
                    tags: tags,
                    description: description,
                    updatedAt: new Date().toISOString()
                };
            } else {
                // Creating new note
                note = {
                    id: Date.now().toString(),
                    title: title,
                    content: content,
                    category: category,
                    tags: tags,
                    description: description,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                };
            }
            
            try {
                await ipcRenderer.invoke('db-save-note', note);
                notes = await ipcRenderer.invoke('db-get-notes');
                
                currentNote = note;
                updateNotesList();
                
                document.getElementById('editor').style.display = 'none';
                document.getElementById('viewer').style.display = 'flex';
                
                // Update viewer
                viewNote(note.id);
                
                showAlert('‚úÖ Success', 'Note "' + title + '" saved!');
            } catch (error) {
                showAlert('‚ùå Error', 'Error saving note: ' + error.message);
            }
        }
        
        function cancelEdit() {
            document.getElementById('editor').style.display = 'none';
            if (currentNote) {
                document.getElementById('viewer').style.display = 'flex';
            } else {
                document.getElementById('welcomeScreen').style.display = 'flex';
            }
        }
        
        let currentVersion = 'Unknown';
        let latestVersion = 'Unknown';
        
        // Get current version from main process
        async function getCurrentVersion() {
            try {
                currentVersion = await ipcRenderer.invoke('get-app-version');
                return currentVersion;
            } catch (error) {
                console.error('Error getting app version:', error);
                return 'Unknown';
            }
        }
        
        // Setup IPC listeners for update events
        ipcRenderer.on('update-checking', () => {
            document.getElementById('updateBtn').textContent = 'Checking...';
            document.getElementById('updateBtn').disabled = true;
        });
        
        ipcRenderer.on('update-available', (event, version) => {
            latestVersion = version;
            document.getElementById('currentVersionText').textContent = currentVersion;
            document.getElementById('latestVersionText').textContent = latestVersion;
            document.getElementById('updateAvailableModal').style.display = 'flex';
            document.getElementById('updateBtn').textContent = 'Check Updates';
            document.getElementById('updateBtn').disabled = false;
        });
        
        ipcRenderer.on('update-not-available', () => {
            showAlert('‚úÖ Up to Date', 'You have the latest version!');
            document.getElementById('updateBtn').textContent = 'Check Updates';
            document.getElementById('updateBtn').disabled = false;
        });
        
        ipcRenderer.on('update-error', (event, error) => {
            showAlert('‚ùå Error', 'Update error: ' + error);
            document.getElementById('updateBtn').textContent = 'Check Updates';
            document.getElementById('updateBtn').disabled = false;
        });
        
        ipcRenderer.on('update-progress', (event, percent) => {
            document.getElementById('updateProgress').style.display = 'block';
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressText').textContent = `Downloading... ${Math.round(percent)}%`;
        });
        
        ipcRenderer.on('update-downloaded', () => {
            document.getElementById('updateProgress').style.display = 'none';
            document.getElementById('installUpdateBtn').textContent = 'Restart & Install';
            document.getElementById('installUpdateBtn').disabled = false;
            showAlert('‚úÖ Download Complete', 'Update downloaded! Click "Restart & Install" to apply the update.');
        });
        
        async function checkForUpdates() {
            await getCurrentVersion();
            await ipcRenderer.invoke('check-for-updates');
        }
        
        function closeUpdateAvailableModal() {
            document.getElementById('updateAvailableModal').style.display = 'none';
        }
        
        async function installUpdate() {
            const installBtn = document.getElementById('installUpdateBtn');
            installBtn.disabled = true;
            installBtn.textContent = 'Installing...';
            
            await ipcRenderer.invoke('install-update');
        }
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initApp();
            initSearchListeners();
        });
        
        // Listen for global shortcuts
        ipcRenderer.on('shortcut-new-note', () => {
            createNewNote();
        });
        
        ipcRenderer.on('shortcut-focus-search', () => {
            document.getElementById('searchInput').focus();
            document.getElementById('searchInput').select();
        });
        
        // Add search functionality
        document.getElementById('searchInput').addEventListener('input', updateNotesList);
        
        // Rich text formatting functions
        function formatText(command) {
            document.execCommand(command, false, null);
            document.getElementById('noteContent').focus();
        }
        
        function formatHeading(tag) {
            document.execCommand('formatBlock', false, tag);
            document.getElementById('noteContent').focus();
        }
        
        function formatCode() {
            const selection = window.getSelection();
            if (selection.toString()) {
                document.execCommand('insertHTML', false, `<code>${selection.toString()}</code>`);
            } else {
                document.execCommand('insertHTML', false, '<code></code>');
            }
            document.getElementById('noteContent').focus();
        }
        
        function highlightText() {
            document.execCommand('hiliteColor', false, '#ffff00');
            document.getElementById('noteContent').focus();
        }
        
        function alignText(alignment) {
            document.execCommand('justify' + alignment.charAt(0).toUpperCase() + alignment.slice(1), false, null);
            document.getElementById('noteContent').focus();
        }
        
        function undoRedo(action) {
            document.execCommand(action, false, null);
            document.getElementById('noteContent').focus();
        }
        

        
        // Search highlighting function
        function highlightSearchTerm(text) {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            if (!searchTerm) return text;
            
            const regex = new RegExp(`(${searchTerm})`, 'gi');
            return text.replace(regex, '<mark style="background: #ffff00; color: #000;">$1</mark>');
        }
        
        // Sorting function
        async function changeSorting() {
            const sortBy = document.getElementById('sortSelector').value;
            notes = await ipcRenderer.invoke('db-get-notes-sorted', sortBy);
            updateNotesList();
        }
        
        // Pin toggle function
        async function togglePin(noteId) {
            try {
                await ipcRenderer.invoke('db-toggle-pin-note', noteId);
                notes = await ipcRenderer.invoke('db-get-notes');
                updateNotesList();
            } catch (error) {
                showAlert('‚ùå Error', 'Error toggling pin: ' + error.message);
            }
        }
        
        // In-note search variables
        let currentMatches = [];
        let currentMatchIndex = -1;
        let originalContent = '';
        
        // Floating search functions
        function openInNoteSearch() {
            const isViewer = document.getElementById('viewer').style.display !== 'none';
            const isEditor = document.getElementById('editor').style.display !== 'none';
            
            if (isViewer || isEditor) {
                const contentElement = isViewer ? document.getElementById('viewerContent') : document.getElementById('noteContent');
                const floatingSearch = document.getElementById('floatingSearch');
                const floatingSearchInput = document.getElementById('floatingSearchInput');
                
                if (contentElement && floatingSearch && floatingSearchInput) {
                    originalContent = contentElement.innerHTML;
                    floatingSearch.style.display = 'flex';
                    floatingSearchInput.focus();
                    floatingSearchInput.value = '';
                    document.getElementById('floatingSearchResults').textContent = '';
                }
            }
        }
        
        function closeFloatingSearch() {
            const floatingSearch = document.getElementById('floatingSearch');
            const floatingSearchInput = document.getElementById('floatingSearchInput');
            const isViewer = document.getElementById('viewer').style.display !== 'none';
            const contentElement = isViewer ? document.getElementById('viewerContent') : document.getElementById('noteContent');
            
            if (floatingSearch) floatingSearch.style.display = 'none';
            if (floatingSearchInput) floatingSearchInput.value = '';
            if (originalContent && contentElement) {
                contentElement.innerHTML = originalContent;
            }
            document.getElementById('floatingSearchResults').textContent = '';
            
            currentMatches = [];
            currentMatchIndex = -1;
        }
        
        function navigateSearch(direction) {
            const searchTerm = document.getElementById('floatingSearchInput').value;
            if (!searchTerm) return;
            
            const isViewer = document.getElementById('viewer').style.display !== 'none';
            const contentElement = isViewer ? document.getElementById('viewerContent') : document.getElementById('noteContent');
            searchInContent(contentElement, searchTerm, direction, 'floatingSearchResults');
        }
        
        function searchInContent(contentElement, searchTerm, direction, resultsId) {
            if (!searchTerm) {
                contentElement.innerHTML = originalContent;
                currentMatches = [];
                currentMatchIndex = -1;
                document.getElementById(resultsId).textContent = '';
                return;
            }
            
            // If this is navigation, just update which match is current
            if (direction && currentMatches.length > 0) {
                if (direction === 'next') {
                    currentMatchIndex = (currentMatchIndex + 1) % currentMatches.length;
                } else if (direction === 'prev') {
                    currentMatchIndex = currentMatchIndex <= 0 ? currentMatches.length - 1 : currentMatchIndex - 1;
                }
                
                // Remove current highlighting
                contentElement.querySelectorAll('.current-match').forEach(el => {
                    el.className = 'search-match';
                    el.removeAttribute('id');
                });
                
                // Highlight new current match
                const allMatches = contentElement.querySelectorAll('.search-match');
                if (allMatches[currentMatchIndex]) {
                    allMatches[currentMatchIndex].className = 'current-match';
                    allMatches[currentMatchIndex].id = 'current-search-match';
                    allMatches[currentMatchIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
                
                document.getElementById(resultsId).textContent = `${currentMatchIndex + 1} of ${currentMatches.length}`;
                return;
            }
            
            // Initial search
            contentElement.innerHTML = originalContent;
            
            const textContent = contentElement.textContent || contentElement.innerText || '';
            const escapedTerm = searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const textMatches = [...textContent.matchAll(new RegExp(escapedTerm, 'gi'))];
            
            if (textMatches.length === 0) {
                document.getElementById(resultsId).textContent = 'No matches';
                return;
            }
            
            currentMatches = textMatches;
            currentMatchIndex = 0;
            
            // Get all text nodes and replace matches
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = originalContent;
            
            let matchIndex = 0;
            const walker = document.createTreeWalker(
                tempDiv,
                NodeFilter.SHOW_TEXT
            );
            
            const textNodes = [];
            let node;
            while (node = walker.nextNode()) {
                textNodes.push(node);
            }
            
            textNodes.forEach(textNode => {
                const text = textNode.textContent;
                if (new RegExp(escapedTerm, 'i').test(text)) {
                    const highlightedText = text.replace(new RegExp(escapedTerm, 'gi'), (match) => {
                        const className = matchIndex === 0 ? 'current-match' : 'search-match';
                        const id = matchIndex === 0 ? 'current-search-match' : '';
                        matchIndex++;
                        return `<span class="${className}" ${id ? `id="${id}"` : ''}>${match}</span>`;
                    });
                    
                    const wrapper = document.createElement('div');
                    wrapper.innerHTML = highlightedText;
                    
                    while (wrapper.firstChild) {
                        textNode.parentNode.insertBefore(wrapper.firstChild, textNode);
                    }
                    textNode.parentNode.removeChild(textNode);
                }
            });
            
            const highlightedHTML = tempDiv.innerHTML;
            
            contentElement.innerHTML = highlightedHTML;
            
            // Scroll to first match
            const firstMatch = document.getElementById('current-search-match');
            if (firstMatch) {
                firstMatch.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
            
            document.getElementById(resultsId).textContent = `1 of ${textMatches.length}`;
        }
        
        // Global keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Only handle shortcuts if no modal is open
            const modalsOpen = document.querySelectorAll('.modal[style*="flex"]').length > 0;
            if (modalsOpen) return;
            
            const isViewer = document.getElementById('viewer').style.display !== 'none';
            const isEditor = document.getElementById('editor').style.display !== 'none';
            
            // Ctrl+S - Save note
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                if (isEditor) {
                    saveCurrentNote();
                }
            }
            
            // Ctrl+N - New note
            if (e.ctrlKey && e.key === 'n') {
                e.preventDefault();
                createNewNote();
            }
            
            // Ctrl+F - Focus search or in-note search
            if (e.ctrlKey && e.key === 'f') {
                e.preventDefault();
                if (isViewer || isEditor) {
                    openInNoteSearch();
                } else {
                    document.getElementById('searchInput').focus();
                    document.getElementById('searchInput').select();
                }
            }
            
            // Escape - Close floating search
            if (e.key === 'Escape') {
                if (document.getElementById('floatingSearch').style.display !== 'none') {
                    closeFloatingSearch();
                }
            }
        });
        
        // Initialize floating search listener
        function initSearchListeners() {
            const floatingSearchInput = document.getElementById('floatingSearchInput');
            
            if (floatingSearchInput) {
                floatingSearchInput.addEventListener('input', function() {
                    const searchTerm = this.value.trim();
                    const isViewer = document.getElementById('viewer').style.display !== 'none';
                    const contentElement = isViewer ? document.getElementById('viewerContent') : document.getElementById('noteContent');
                    
                    if (searchTerm && contentElement) {
                        searchInContent(contentElement, searchTerm, null, 'floatingSearchResults');
                    } else if (contentElement && originalContent) {
                        contentElement.innerHTML = originalContent;
                        document.getElementById('floatingSearchResults').textContent = '';
                    }
                });
            }
        }
    </script>
</body>
</html>